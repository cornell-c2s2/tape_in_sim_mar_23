//-------------------------------------------------------------------------
// FFTSPIMinionRTL.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder tape_in_FFT_interconnectVRTL Definition
// Full name: tape_in_FFT_interconnectVRTL_noparam
// At /home/will/Desktop/C2S2-Main/tape_in_sim_mar_23/sim/tape_in_FFT_interconnect/tape_in_FFT_interconnectRTL.py

//***********************************************************
// Pickled source file of placeholder tape_in_FFT_interconnectVRTL_noparam
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder tape_in_FFT_interconnectVRTL
//-----------------------------------------------------------

`ifndef TAPE_IN_FFT_INTERCONNECTVRTL
`define TAPE_IN_FFT_INTERCONNECTVRTL

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component tape_in_FFT_interconnectVRTL_noparam.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component tape_in_FFT_interconnectVRTL_noparam

`line 1 "tape_in_FFT_interconnectVRTL.v" 0
`ifndef TAPE_IN_FFT_INTERCONNECT_VRTL
`define TAPE_IN_FFT_INTERCONNECT_VRTL

`line 1 "../../../C2S2-Module-Library/sim/spi/SPIMasterValRdyVRTL.v" 0
/*
==========================================================================
SPIMasterValRdyVRTL.v
==========================================================================
SPIMaster module for sending messages over SPI.
Supports SPI mode 0.

Author : Kyle Infantino
  Date : April 26, 2022

*/

/*
Note for C2S2 future development:
We can add support for different frequencies. Currently, SPI Master
runs at 1/2 of the system clock. However, we can add cycles to lower the
frequency. We will need a modified FSM and input from chip so that we 
can dynamically lower or raise the SPI frequency.
*/

/*
Notes 3/11/2023
Adding an extra state that will serve to divide frequency. Using a 
variable called freq_div_count, we will check if we need to add 
additional cycles to make the system 1/2 slower (keep in mind that the 
SPI Master is alread 1/2 of the master system clock). freq_div_count 
will obtain its value from a configuration register that is outside the 
SPI Master files. 

-Austin
*/

/*
Notes 3/12/2023
We need to consider when the FSM enters CS_LOW_WAIT. Because we are 
following the set frequency, there is the need for the CS_LOW_HOLD 
state to assess if it needs to go to the CS_LOW_WAIT state.

I added some logic to allow for frequency counter to be refilled
after countdown complete. Will refill value after the 

-Austin
*/

/*
Notes 3/20/2023
I failed to account for the fact that the divisor of the frequency
should be squared. What was happening was that the counter for the 
hold states will only run for the number stored in freq. Therefore, 
256 cycles actually turns out to be 7.

There was also an issue with the shift registers. Our design with
the hold states affected the posedge and negedge of the clock.
However, this would cause the registers to shift data during our
hold states. The hold states no longer have an impact on posedge
or negedge.

Negedge and posedge may need own states.

In the next version of SPI Master, we can include support for SPI
modes 1-3. This will require that we add additional states for each
mode. This will also require that the sclk_posedge and sclk_negedge
are changed to be more general controls such as shift_in_enable
and shift_out_enable.
-Austin
*/

/*
Notes 3/20/2023
This week, I have made some bug adjustments. First I fixed the new 
state machine to accurately depict when positive and negative clock
edges are on.

Currently, there is an issue with the number of hold cycles being
run. When running the desired number of cycles, we get an erroneous
number. Right now, if 7 was written then 8 hold cycles run instead
of 127.
-Austin
*/

`ifndef SPI_V3_COMPONENTS_SPIMASTER_V
`define SPI_V3_COMPONENTS_SPIMASTER_V

`line 1 "../../../C2S2-Module-Library/sim/spi/ShiftReg.v" 0
/*
==========================================================================
ShiftReg.v
==========================================================================
N-bit shift register.
*/

`ifndef SPI_V3_COMPONENTS_SHIFTREG_V
`define SPI_V3_COMPONENTS_SHIFTREG_V

module SPI_v3_components_ShiftReg
#(
    parameter nbits = 8,
    parameter reset_value = 1'b0
)
(
  input  logic             clk,
  input  logic             in_,
  input  logic [nbits-1:0] load_data,
  input  logic             load_en,
  output logic [nbits-1:0] out,
  input  logic             reset,
  input  logic             shift_en 
);
  
  always_ff @(posedge clk) begin 
    if ( reset ) begin
      out <= { nbits{reset_value}};
    end else if ( load_en ) begin
      out <= load_data;
    end else if ( ( ~load_en ) & shift_en ) begin
      out <= { out[nbits-2:0], in_ };
    end
  end

endmodule

`endif /* SPI_V3_COMPONENTS_SHIFTREG_V */
`line 85 "../../../C2S2-Module-Library/sim/spi/SPIMasterValRdyVRTL.v" 0
`line 1 "../../../C2S2-Module-Library/sim/spi/regs.v" 0
//========================================================================
// Verilog Components: Registers
//========================================================================

// Note that we place the register output earlier in the port list since
// this is one place we might actually want to use positional port
// binding like this:
//
//  logic [p_nbits-1:0] result_B;
//  vc_Reg#(p_nbits) result_AB( clk, result_B, result_A );

`ifndef VC_REGS_V
`define VC_REGS_V

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop
//------------------------------------------------------------------------

module vc_Reg
#(
  parameter p_nbits = 1
)(
  input  logic               clk, // Clock input
  output logic [p_nbits-1:0] q,   // Data output
  input  logic [p_nbits-1:0] d    // Data input
);

  always_ff @( posedge clk )
    q <= d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with reset
//------------------------------------------------------------------------

module vc_ResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d      // Data input
);

  always_ff @( posedge clk )
    q <= reset ? p_reset_value : d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable
//------------------------------------------------------------------------

module vc_EnReg
#(
  parameter p_nbits = 1
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( en )
      q <= d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable and reset
//------------------------------------------------------------------------

module vc_EnResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( reset || en )
      q <= reset ? p_reset_value : d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

`endif /* VC_REGS_V */


`line 86 "../../../C2S2-Module-Library/sim/spi/SPIMasterValRdyVRTL.v" 0

module SPIMasterValRdyVRTL
#(
  parameter nbits = 34, 
  parameter ncs = 1,
  parameter logBitsN = $clog2(nbits)+1,
  parameter logCSN = ncs > 1 ? $clog2(ncs) : 1
)
(
  input  logic                clk,
  input  logic                reset,

  output logic                spi_ifc_cs [0:ncs-1],
  input  logic                spi_ifc_miso,
  output logic                spi_ifc_mosi,
  output logic                spi_ifc_sclk,

  input  logic                recv_val,
  output logic                recv_rdy,
  input  logic [nbits-1:0]    recv_msg,

  output logic                send_val,
  input  logic                send_rdy,
  output logic [nbits-1:0]    send_msg,

  input  logic                packet_size_ifc_val,
  output logic                packet_size_ifc_rdy,
  input  logic [logBitsN-1:0] packet_size_ifc_msg,

  input  logic                cs_addr_ifc_val,
  output logic                cs_addr_ifc_rdy,
  input  logic [logCSN-1:0]   cs_addr_ifc_msg,

  input  logic                freq_ifc_val, //new 
  output logic                freq_ifc_rdy, //new 
  input  logic [2:0]          freq_ifc_msg //new
);

  logic [logBitsN-1:0] packet_size_reg_out;
  logic                packet_size_reg_en;
  logic [logCSN-1:0]   cs_addr_reg_out;
  logic                cs_addr_reg_en;
  logic [logBitsN-1:0] sclk_counter;
  logic                sclk_counter_en;
  logic [6:0]          freq_high_counter; //new
  logic                freq_high_counter_en; //new
  logic [6:0]          freq_low_counter; //new
  logic                freq_low_counter_en; //new
  logic [2:0]          freq_reg_out; //new
  logic                freq_reg_en; //new
  logic [nbits-1:0]    shreg_in_out;
  logic [nbits-1:0]    shreg_out_out;
  logic                freq_high_refill;
  logic                freq_low_refill;

  vc_EnResetReg #(logBitsN) packet_size_reg (
    .clk(clk),   
    .reset(reset), 
    .q(packet_size_reg_out),     
    .d(packet_size_ifc_msg),     
    .en(packet_size_reg_en)     
  );

  vc_EnResetReg #(logCSN) cs_addr_reg (
    .clk(clk),   
    .reset(reset), 
    .q(cs_addr_reg_out),     
    .d(cs_addr_ifc_msg),     
    .en(cs_addr_reg_en)     
  );

  vc_EnResetReg #(3) freq_reg (
    .clk(clk),   
    .reset(reset), 
    .q(freq_reg_out),     
    .d(freq_ifc_msg),     
    .en(freq_reg_en)     
  );

  assign packet_size_ifc_rdy = recv_rdy;
  assign cs_addr_ifc_rdy = recv_rdy;
  assign freq_ifc_rdy = recv_rdy; //new

  logic sclk_negedge;
  logic sclk_posedge;
  logic shreg_out_rst;

  typedef enum logic [3:0] {STATE_INIT, STATE_START0, STATE_START1, STATE_SCLK_HIGH, 
                            STATE_SCLK_LOW, STATE_SCLK_HIGH_HOLD, STATE_SCLK_LOW_HOLD, 
                            STATE_CS_LOW_WAIT, STATE_DONE} state_t;

  state_t state, next_state;

  //state transition logic
  always_ff @( posedge clk ) begin : up_state
    if (reset) state <= STATE_INIT;
    else state <= next_state; 
  end

  //next state logic
  always_comb begin : up_stateChange
    case(state)
      STATE_INIT : next_state = (recv_val) ? STATE_START0 : STATE_INIT;
      STATE_START0 : next_state = STATE_START1;
      STATE_START1 : next_state = STATE_SCLK_HIGH;
      STATE_SCLK_HIGH : 
        if (freq_high_counter == 0) next_state = STATE_SCLK_LOW;
        else next_state = STATE_SCLK_HIGH_HOLD;
      STATE_SCLK_LOW : 
        if (freq_low_counter == 0) next_state = (sclk_counter == 0) ? STATE_CS_LOW_WAIT : STATE_SCLK_HIGH;
        else next_state = STATE_SCLK_LOW_HOLD;
      STATE_SCLK_HIGH_HOLD : //new
        if (freq_high_counter == 0) next_state = STATE_SCLK_LOW;
        else next_state = STATE_SCLK_HIGH_HOLD;
      STATE_SCLK_LOW_HOLD : //new
        if (freq_low_counter == 0) next_state = (sclk_counter == 0) ? STATE_CS_LOW_WAIT : STATE_SCLK_HIGH;
        else next_state = STATE_SCLK_LOW_HOLD;
      STATE_CS_LOW_WAIT : next_state = STATE_DONE;
      STATE_DONE : begin
        if (recv_val) next_state = STATE_START0;
        else if (send_rdy) next_state = STATE_INIT;
        else next_state = STATE_DONE;
      end
      default : next_state = STATE_INIT;
    endcase
  end
    
  // state outputs
  always_comb begin : up_stateOutputs
    recv_rdy = 0;
    send_val = 0;
    spi_ifc_sclk = 0;
    packet_size_reg_en = 0;
    cs_addr_reg_en = 0;
    for (integer i=0; i < ncs; i++) begin
      spi_ifc_cs[i] = 1;
    end
    sclk_negedge = 0;
    sclk_posedge = 0;
    sclk_counter_en = 0;
    shreg_out_rst = 0;
    freq_high_refill = 0;
    freq_low_refill = 0;
    freq_high_counter_en = 0;
    freq_low_counter_en = 0;


    if (state == STATE_INIT) begin
      recv_rdy           = 1;
      packet_size_reg_en = packet_size_ifc_val;
      cs_addr_reg_en     = cs_addr_ifc_val;
      freq_reg_en        = freq_ifc_val;
    end else if (state == STATE_START0) begin
      spi_ifc_cs[cs_addr_reg_out] = 0;
      shreg_out_rst       = 1;
    end else if (state == STATE_START1) begin
      sclk_posedge        = 1;
      spi_ifc_cs[cs_addr_reg_out] = 0;
    end else if (state == STATE_SCLK_HIGH) begin
      spi_ifc_cs[cs_addr_reg_out] = 0;
      spi_ifc_sclk                = 1;
      sclk_negedge                 = (freq_high_counter == 0);
      sclk_counter_en              = 1;
      freq_high_counter_en         = 1;
      freq_low_refill              = 1;
    end else if (state == STATE_SCLK_LOW) begin
      sclk_posedge                = ((sclk_counter != 0) && (freq_low_counter == 0));
      spi_ifc_cs[cs_addr_reg_out] = 0;
      spi_ifc_sclk                = 0;
      freq_low_counter_en         = 1;
      freq_high_refill             = 1;
    end else if (state == STATE_SCLK_HIGH_HOLD) begin
      spi_ifc_cs[cs_addr_reg_out] = 0;
      spi_ifc_sclk                = 1;
      sclk_negedge                 = (freq_high_counter == 0);
      sclk_counter_en              = 0;
      freq_high_counter_en         = 1;
    end else if (state == STATE_SCLK_LOW_HOLD) begin
      sclk_posedge                = ((sclk_counter != 0) && (freq_low_counter == 0));
      spi_ifc_cs[cs_addr_reg_out] = 0;
      spi_ifc_sclk                = 0;
      freq_low_counter_en         = 1;
    end else if (state == STATE_CS_LOW_WAIT) begin
      spi_ifc_cs[cs_addr_reg_out] = 0;
    end else if (state == STATE_DONE) begin
      recv_rdy           = 1;
      send_val           = 1;
      packet_size_reg_en = packet_size_ifc_val;
      cs_addr_reg_en     = cs_addr_ifc_val;
      freq_reg_en        = freq_ifc_val;
    end
  end

  //sclk counter logic
  always_ff @( posedge clk ) begin
    if (reset) sclk_counter <= 0;
    else if (recv_val & recv_rdy) sclk_counter <= packet_size_reg_out;
    else if (sclk_counter_en) sclk_counter <= sclk_counter - 1;
  end

  //freq positive counter logic
  always_ff @( posedge clk ) begin
    if (reset) freq_high_counter <= 0;
    else if ((recv_val & recv_rdy) | freq_high_refill) begin
      freq_high_counter <= 2**freq_reg_out-1;
    end
    else if (freq_high_counter_en) freq_high_counter <= freq_high_counter - 1;
  end

  //freq negative counter logic
  always_ff @( posedge clk ) begin
    if (reset) freq_low_counter <= 0;
    else if ((recv_val & recv_rdy) | freq_low_refill) begin
      freq_low_counter <= 2**freq_reg_out-1;
    end
    else if (freq_low_counter_en) freq_low_counter <= freq_low_counter - 1;
  end

  //Datapath
  SPI_v3_components_ShiftReg #(nbits, 1'b0) shreg_in 
  (
    .clk(clk),
    .in_(spi_ifc_miso),
    .load_data(0),
    .load_en(0),
    .out(shreg_in_out),
    .reset(shreg_out_rst),
    .shift_en(sclk_posedge) 
  );

  SPI_v3_components_ShiftReg #(nbits, 1'b0) shreg_out 
  (
    .clk(clk),
    .in_(0),
    .load_data(recv_msg << (nbits-packet_size_reg_out)), // put message into most significant bits
    .load_en(recv_rdy & recv_val),
    .out(shreg_out_out),
    .reset(reset),
    .shift_en(sclk_negedge) 
  );

  assign spi_ifc_mosi = shreg_out_out[nbits-1];
  assign send_msg = shreg_in_out;

endmodule

`endif /*SPI_V3_COMPONENTS_SPIMASTER_V*/

`line 5 "tape_in_FFT_interconnectVRTL.v" 0
`line 1 "../../../spi_minion/sim/SPI_minion/components/SPIMinionAdapterConnectedVRTL.v" 0
`line 1 "../../../spi_minion/sim/SPI_minion/components/SPIMinionVRTL.v" 0
// ==========================================================================
// SPIMinionVRTL.v
// ==========================================================================
// SPIMinion module. Supports SPI mode 0

// Author : Yanghui Ou, Modified by Kyle Infantino

`ifndef SPI_MINION_COMPONENTS_MINION_V
`define SPI_MINION_COMPONENTS_MINION_V

`line 1 "../../../spi_minion/sim/SPI_minion/components/ShiftReg.v" 0
/*
==========================================================================
ShiftReg.v
==========================================================================
N-bit shift register.
*/

`ifndef SPI_MINION_COMPONENTS_SHIFTREG_V
`define SPI_MINION_COMPONENTS_SHIFTREG_V

module SPI_minion_components_ShiftReg
#(
    parameter nbits = 8,
    parameter reset_value = 1'b0
)
(
  input  logic             clk,
  input  logic             in_,
  input  logic [nbits-1:0] load_data,
  input  logic             load_en,
  output logic [nbits-1:0] out,
  input  logic             reset,
  input  logic             shift_en 
);
  
  always_ff @(posedge clk) begin 
    if ( reset ) begin
      out <= { nbits{reset_value}};
    end else if ( load_en ) begin
      out <= load_data;
    end else if ( ( ~load_en ) & shift_en ) begin
      out <= { out[nbits-2:0], in_ };
    end
  end

endmodule

`endif /* SPI_MINION_COMPONENTS_SHIFTREG_V */
`line 12 "../../../spi_minion/sim/SPI_minion/components/SPIMinionVRTL.v" 0
`line 1 "../../../spi_minion/sim/SPI_minion/components/Synchronizer.v" 0
/*
==========================================================================
Synchronizer.v
==========================================================================
 - RTL code for the Synchronizer module.
 - It samples the input signal using the device clock and also detects
     positive and negative edges.
 - Reference: https://www.fpga4fun.com/SPI2.html
*/

`ifndef SPI_MINION_COMPONENTS_SYNCHRONIZER_V
`define SPI_MINION_COMPONENTS_SYNCHRONIZER_V

module SPI_minion_components_Synchronizer 
#(
  parameter reset_value = 1'b0
)(
  input  logic clk ,
  input  logic in_,
  output logic negedge_,
  output logic out,
  output logic posedge_,
  input  logic reset 
);

  logic [2:0] shreg;
  
  always_comb begin
    negedge_ = shreg[2] & ( ~shreg[1] );
    posedge_ = ( ~shreg[2] ) & shreg[1];
  end
  
  always_ff @(posedge clk) begin
    if ( reset ) begin
      shreg <= { 3{reset_value} };
    end
    else
      shreg <= { shreg[1:0], in_ };
  end

  assign out = shreg[1];

endmodule

`endif /* SPI_MINION_COMPONENTS_SYNCHRONIZER_V */
`line 13 "../../../spi_minion/sim/SPI_minion/components/SPIMinionVRTL.v" 0

module SPI_minion_components_SPIMinionVRTL
#(
  parameter nbits = 8
)
(
  input  logic             clk,
  input  logic             cs,
  output logic             miso,
  input  logic             mosi,
  input  logic             reset,
  input  logic             sclk,
  output logic             pull_en,
  input  logic [nbits-1:0] pull_msg,
  output logic             push_en,
  output logic [nbits-1:0] push_msg,  
  output logic             parity
);
  //-------------------------------------------------------------
  // Component cs_sync
  //-------------------------------------------------------------

  logic cs_sync_clk;
  logic cs_sync_in_;
  logic cs_sync_negedge_;
  logic cs_sync_out;
  logic cs_sync_posedge_;
  logic cs_sync_reset;

  SPI_minion_components_Synchronizer #(1'b1) cs_sync
  (
    .clk( cs_sync_clk ),
    .in_( cs_sync_in_ ),
    .negedge_( cs_sync_negedge_ ),
    .out( cs_sync_out ),
    .posedge_( cs_sync_posedge_ ),
    .reset( cs_sync_reset )
  );

  //-------------------------------------------------------------
  // Component mosi_sync
  //-------------------------------------------------------------

  logic mosi_sync_clk;
  logic mosi_sync_in_;
  logic mosi_sync_negedge_;
  logic mosi_sync_out;
  logic mosi_sync_posedge_;
  logic mosi_sync_reset;

  SPI_minion_components_Synchronizer #(1'b0) mosi_sync
  (
    .clk( mosi_sync_clk ),
    .in_( mosi_sync_in_ ),
    .negedge_( mosi_sync_negedge_ ),
    .out( mosi_sync_out ),
    .posedge_( mosi_sync_posedge_ ),
    .reset( mosi_sync_reset )
  );

  //-------------------------------------------------------------
  // Component sclk_sync
  //-------------------------------------------------------------

  logic sclk_sync_clk;
  logic sclk_sync_in_;
  logic sclk_sync_negedge_;
  logic sclk_sync_out;
  logic sclk_sync_posedge_;
  logic sclk_sync_reset;

  SPI_minion_components_Synchronizer #(1'b0) sclk_sync
  (
    .clk( sclk_sync_clk ),
    .in_( sclk_sync_in_ ),
    .negedge_( sclk_sync_negedge_ ),
    .out( sclk_sync_out ),
    .posedge_( sclk_sync_posedge_ ),
    .reset( sclk_sync_reset )
  );

  //-------------------------------------------------------------
  // Component shreg_in
  //-------------------------------------------------------------

  logic             shreg_in_clk;
  logic             shreg_in_in_;
  logic [nbits-1:0] shreg_in_load_data;
  logic             shreg_in_load_en;
  logic [nbits-1:0] shreg_in_out;
  logic             shreg_in_reset;
  logic             shreg_in_shift_en;

  SPI_minion_components_ShiftReg #( nbits ) shreg_in
  (
    .clk( shreg_in_clk ),
    .in_( shreg_in_in_ ),
    .load_data( shreg_in_load_data ),
    .load_en( shreg_in_load_en ),
    .out( shreg_in_out ),
    .reset( shreg_in_reset ),
    .shift_en( shreg_in_shift_en )
  );

  //-------------------------------------------------------------
  // Component shreg_out
  //-------------------------------------------------------------

  logic             shreg_out_clk;
  logic             shreg_out_in_;
  logic [nbits-1:0] shreg_out_load_data;
  logic             shreg_out_load_en;
  logic [nbits-1:0] shreg_out_out;
  logic             shreg_out_reset;
  logic             shreg_out_shift_en;

  SPI_minion_components_ShiftReg #( nbits ) shreg_out
  (
    .clk( shreg_out_clk ),
    .in_( shreg_out_in_ ),
    .load_data( shreg_out_load_data ),
    .load_en( shreg_out_load_en ),
    .out( shreg_out_out ),
    .reset( shreg_out_reset ),
    .shift_en( shreg_out_shift_en )
  );
  
  always_comb begin
    shreg_in_shift_en = ( ~cs_sync_out ) & sclk_sync_posedge_;
    shreg_out_shift_en = ( ~cs_sync_out ) & sclk_sync_negedge_;
  end

  assign cs_sync_clk         = clk;
  assign cs_sync_reset       = reset;
  assign cs_sync_in_         = cs;
  assign sclk_sync_clk       = clk;
  assign sclk_sync_reset     = reset;
  assign sclk_sync_in_       = sclk;
  assign mosi_sync_clk       = clk;
  assign mosi_sync_reset     = reset;
  assign mosi_sync_in_       = mosi;
  assign shreg_in_clk        = clk;
  assign shreg_in_reset      = reset;
  assign shreg_in_in_        = mosi_sync_out;
  assign shreg_in_load_en    = 1'b0;
  assign shreg_in_load_data  = {nbits{1'b0}};
  assign shreg_out_clk       = clk;
  assign shreg_out_reset     = reset;
  assign shreg_out_in_       = 1'b0;
  assign shreg_out_load_en   = pull_en;
  assign shreg_out_load_data = pull_msg;
  assign miso                = shreg_out_out[nbits-1];
  assign pull_en             = cs_sync_negedge_;
  assign push_en             = cs_sync_posedge_;
  assign push_msg            = shreg_in_out;
  assign parity              = (^push_msg[nbits-3:0]) & push_en;

endmodule

`endif /* SPI_MINION_COMPONENTS_MINION_V */
`line 2 "../../../spi_minion/sim/SPI_minion/components/SPIMinionAdapterConnectedVRTL.v" 0
`line 1 "../../../spi_minion/sim/SPI_minion/components/SPIMinionAdapterVRTL.v" 0
// ==========================================================================
// SPIMinionAdapterVRTL.v
// ==========================================================================
// An Adapter that converts push/pull interface from SPI to val/rdy interfaces. 

// Author : Kyle Infantino
// Date : Nov 30, 2021

`ifndef SPI_MINION_COMPONENTS_MINION_ADAPTER_V
`define SPI_MINION_COMPONENTS_MINION_ADAPTER_V

`line 1 "../../../spi_minion/sim/vc/queues.v" 0
//========================================================================
// Verilog Components: Queues
//========================================================================

`ifndef VC_QUEUES_V
`define VC_QUEUES_V

`line 1 "../../../spi_minion/sim/vc/regs.v" 0
//========================================================================
// Verilog Components: Registers
//========================================================================

// Note that we place the register output earlier in the port list since
// this is one place we might actually want to use positional port
// binding like this:
//
//  logic [p_nbits-1:0] result_B;
//  vc_Reg#(p_nbits) result_AB( clk, result_B, result_A );

`ifndef VC_REGS_V
`define VC_REGS_V

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop
//------------------------------------------------------------------------

module vc_Reg
#(
  parameter p_nbits = 1
)(
  input  logic               clk, // Clock input
  output logic [p_nbits-1:0] q,   // Data output
  input  logic [p_nbits-1:0] d    // Data input
);

  always_ff @( posedge clk )
    q <= d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with reset
//------------------------------------------------------------------------

module vc_ResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d      // Data input
);

  always_ff @( posedge clk )
    q <= reset ? p_reset_value : d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable
//------------------------------------------------------------------------

module vc_EnReg
#(
  parameter p_nbits = 1
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( en )
      q <= d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable and reset
//------------------------------------------------------------------------

module vc_EnResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( reset || en )
      q <= reset ? p_reset_value : d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

`endif /* VC_REGS_V */
`line 9 "../../../spi_minion/sim/vc/queues.v" 0
`line 1 "../../../spi_minion/sim/vc/muxes.v" 0
//========================================================================
// Verilog Components: Muxes
//========================================================================

`ifndef VC_MUXES_V
`define VC_MUXES_V

//------------------------------------------------------------------------
// 2 Input Mux
//------------------------------------------------------------------------

module vc_Mux2
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1,
  input  logic               sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      1'd0 : out = in0;
      1'd1 : out = in1;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 3 Input Mux
//------------------------------------------------------------------------

module vc_Mux3
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 4 Input Mux
//------------------------------------------------------------------------

module vc_Mux4
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      2'd3 : out = in3;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 5 Input Mux
//------------------------------------------------------------------------

module vc_Mux5
#(
 parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 6 Input Mux
//------------------------------------------------------------------------

module vc_Mux6
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 7 Input Mux
//------------------------------------------------------------------------

module vc_Mux7
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 8 Input Mux
//------------------------------------------------------------------------

module vc_Mux8
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6, in7,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      3'd7 : out = in7;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// N Input Mux
//------------------------------------------------------------------------

module vc_MuxN
#(
  parameter p_nbits = 1,
  parameter p_ninputs = 2
)(
  input  logic [p_ninputs-1:0][p_nbits-1:0] in,
  input  logic [$clog2(p_ninputs)-1:0]      sel,
  output logic [p_nbits-1:0]                out
);

  assign out = in[sel];

endmodule

`endif /* VC_MUXES_V */
`line 10 "../../../spi_minion/sim/vc/queues.v" 0
`line 1 "../../../spi_minion/sim/vc/regfiles.v" 0
//========================================================================
// Verilog Components: Register Files
//========================================================================

`ifndef VC_REGFILES_V
`define VC_REGFILES_V

//------------------------------------------------------------------------
// 1r1w register file
//------------------------------------------------------------------------

module vc_Regfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );
      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.
      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end
    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 1r1w register file with reset
//------------------------------------------------------------------------

module vc_ResetRegfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,
  parameter p_reset_value = 0,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge. We have to use a generate statement to
  // allow us to include the reset logic for each individual register.

  genvar i;
  generate
    for ( i = 0; i < p_num_entries; i = i+1 )
    begin : wport
      always_ff @( posedge clk )
        if ( reset )
          rfile[i] <= p_reset_value;
        else if ( write_en && (i[c_addr_nbits-1:0] == write_addr) )
          rfile[i] <= write_data;
    end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );
      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.
      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end
    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r1w register file
//------------------------------------------------------------------------

module vc_Regfile_2r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                   clk,
  input  logic                   reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );
      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.
      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end
    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r2w register file
//------------------------------------------------------------------------

module vc_Regfile_2r2w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en0,
  input  logic [c_addr_nbits-1:0] write_addr0,
  input  logic [p_data_nbits-1:0] write_data0,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en1,
  input  logic [c_addr_nbits-1:0] write_addr1,
  input  logic [p_data_nbits-1:0] write_data1
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk ) begin

    if ( write_en0 )
      rfile[write_addr0] <= write_data0;

    if ( write_en1 )
      rfile[write_addr1] <= write_data1;

  end

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en0 );
      `VC_ASSERT_NOT_X( write_en1 );
      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.
      if ( write_en0 ) begin
        `VC_ASSERT_NOT_X( write_addr0 );
        `VC_ASSERT( write_addr0 < p_num_entries );
      end
      if ( write_en1 ) begin
        `VC_ASSERT_NOT_X( write_addr1 );
        `VC_ASSERT( write_addr1 < p_num_entries );
      end
      // It is invalid to use the same write address for both write ports
      if ( write_en0 && write_en1 ) begin
        `VC_ASSERT( write_addr0 != write_addr1 );
      end
    end
  end
  */

endmodule

//------------------------------------------------------------------------
// Register file specialized for r0 == 0
//------------------------------------------------------------------------

module vc_Regfile_2r1w_zero
(
  input  logic        clk,
  input  logic        reset,

  input  logic  [4:0] rd_addr0,
  output logic [31:0] rd_data0,

  input  logic  [4:0] rd_addr1,
  output logic [31:0] rd_data1,

  input  logic        wr_en,
  input  logic  [4:0] wr_addr,
  input  logic [31:0] wr_data
);

  // these wires are to be hooked up to the actual register file read
  // ports

  logic [31:0] rf_read_data0;
  logic [31:0] rf_read_data1;

  vc_Regfile_2r1w
  #(
    .p_data_nbits  (32),
    .p_num_entries (32)
  )
  rfile
  (
    .clk         (clk),
    .reset       (reset),
    .read_addr0  (rd_addr0),
    .read_data0  (rf_read_data0),
    .read_addr1  (rd_addr1),
    .read_data1  (rf_read_data1),
    .write_en    (wr_en),
    .write_addr  (wr_addr),
    .write_data  (wr_data)
  );

  // we pick 0 value when either read address is 0
  assign rd_data0 = ( rd_addr0 == 5'd0 ) ? 32'd0 : rf_read_data0;
  assign rd_data1 = ( rd_addr1 == 5'd0 ) ? 32'd0 : rf_read_data1;

endmodule

`endif /* VC_REGFILES_V */
`line 11 "../../../spi_minion/sim/vc/queues.v" 0
`line 1 "../../../spi_minion/sim/vc/trace.v" 0
//========================================================================
// Line Tracing
//========================================================================

`ifndef VC_TRACE_V
`define VC_TRACE_V

// NOTE: This macro is declared outside of the module to allow some vc
// modules to see it and use it in their own params. Verilog does not
// allow other modules to hierarchically reference the nbits localparam
// inside this module in constant expressions (e.g., localparams).

`define VC_TRACE_NCHARS 512
`define VC_TRACE_NBITS  512*8

`ifndef SYNTHESIS

module vc_Trace
(
  input logic clk,
  input logic reset
);

  integer len0;
  integer len1;
  integer idx0;
  integer idx1;

  // NOTE: If you change these, then you also need to change the
  // hard-coded constant in the declaration of the trace function at the
  // bottom of this file.
  // NOTE: You would also need to change the VC_TRACE_NBITS and
  // VC_TRACE_NCHARS macro at the top of this file.

  localparam nchars = 512;
  localparam nbits  = 512*8;

  // This is the actual trace storage used when displaying a trace

  logic [nbits-1:0] storage;

  // Meant to be accesible from outside module

  integer cycles_next = 0;
  integer cycles      = 0;

  // Get trace level from command line

  logic [3:0] level;

`ifndef VERILATOR
  initial begin
    if ( !$value$plusargs( "trace=%d", level ) ) begin
      level = 0;
    end
  end
`else
  initial begin
    level = 1;
  end
`endif // !`ifndef VERILATOR

  // Track cycle count

  always_ff @( posedge clk ) begin
    cycles <= ( reset ) ? 0 : cycles_next;
  end

  //----------------------------------------------------------------------
  // append_str
  //----------------------------------------------------------------------
  // Appends a string to the trace.

  task append_str
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    len0 = 1;
    while ( str[len0*8+:8] != 0 ) begin
      len0 = len0 + 1;
    end

    idx0 = trace[31:0];

    for ( idx1 = len0-1; idx1 >= 0; idx1 = idx1 - 1 )
    begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8 +: 8 ];
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_str_ljust
  //----------------------------------------------------------------------
  // Appends a left-justified string to the trace.

  task append_str_ljust
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    idx0 = trace[31:0];
    idx1 = nchars;

    while ( str[ idx1*8-1 -: 8 ] != 0 ) begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8-1 -: 8 ];
      idx0 = idx0 - 1;
      idx1 = idx1 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_chars
  //----------------------------------------------------------------------
  // Appends the given number of characters to the trace.

  task append_chars
  (
    inout logic   [nbits-1:0] trace,
    input logic         [7:0] char,
    input integer             num
  );
  begin

    idx0 = trace[31:0];

    for ( idx1 = 0;
          idx1 < num;
          idx1 = idx1 + 1 )
    begin
      trace[idx0*8+:8] = char;
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_val_str
  //----------------------------------------------------------------------
  // Append a string modified by val signal.

  task append_val_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val )
      append_str( trace, str );
    else if ( !val )
      append_chars( trace, " ", len1 );
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

  //----------------------------------------------------------------------
  // val_rdy_str
  //----------------------------------------------------------------------
  // Append a string modified by val/rdy signals.

  task append_val_rdy_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic             rdy,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val & rdy ) begin
      append_str( trace, str );
    end
    else if ( rdy && !val ) begin
      append_chars( trace, " ", len1 );
    end
    else if ( !rdy && !val ) begin
      append_str( trace, "." );
      append_chars( trace, " ", len1-1 );
    end
    else if ( !rdy && val ) begin
      append_str( trace, "#" );
      append_chars( trace, " ", len1-1 );
    end
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

endmodule

`endif /* SYNTHESIS */

//------------------------------------------------------------------------
// VC_TRACE_NBITS_TO_NCHARS
//------------------------------------------------------------------------
// Macro to determine number of characters for a net

`define VC_TRACE_NBITS_TO_NCHARS( nbits_ ) ((nbits_+3)/4)

//------------------------------------------------------------------------
// VC_TRACE_BEGIN
//------------------------------------------------------------------------

//`define VC_TRACE_BEGIN                                                  \
//  export "DPI-C" task line_trace;                                       \
//  vc_Trace vc_trace(clk,reset);                                         \
//  task line_trace( inout bit [(512*8)-1:0] trace_str );

`ifndef VERILATOR
`define VC_TRACE_BEGIN                                                  \
  vc_Trace vc_trace(clk,reset);                                         \
                                                                        \
  task display_trace;                                                   \
  begin                                                                 \
                                                                        \
    if ( vc_trace.level > 0 ) begin                                     \
      vc_trace.storage[15:0] = vc_trace.nchars-1;                       \
                                                                        \
      line_trace( vc_trace.storage );                                   \
                                                                        \
      $write( "%4d: ", vc_trace.cycles );                               \
                                                                        \
      vc_trace.idx0 = vc_trace.storage[15:0];                           \
      for ( vc_trace.idx1 = vc_trace.nchars-1;                          \
            vc_trace.idx1 > vc_trace.idx0;                              \
            vc_trace.idx1 = vc_trace.idx1 - 1 )                         \
      begin                                                             \
        $write( "%s", vc_trace.storage[vc_trace.idx1*8+:8] );           \
      end                                                               \
      $write("\n");                                                     \
                                                                        \
    end                                                                 \
                                                                        \
    vc_trace.cycles_next = vc_trace.cycles + 1;                         \
                                                                        \
  end                                                                   \
  endtask                                                               \
                                                                        \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`else
`define VC_TRACE_BEGIN                                                  \
  export "DPI-C" task line_trace;                                       \
  vc_Trace vc_trace(clk,reset);                                         \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`endif

//------------------------------------------------------------------------
// VC_TRACE_END
//------------------------------------------------------------------------

`define VC_TRACE_END \
  endtask

`endif /* VC_TRACE_V */
`line 12 "../../../spi_minion/sim/vc/queues.v" 0

//------------------------------------------------------------------------
// Defines
//------------------------------------------------------------------------

`define VC_QUEUE_NORMAL   4'b0000
`define VC_QUEUE_PIPE     4'b0001
`define VC_QUEUE_BYPASS   4'b0010

//------------------------------------------------------------------------
// Single-Element Queue Control Logic
//------------------------------------------------------------------------
// This is the control logic for a single-elment queue. It is designed to
// be attached to a storage element with a write enable. Additionally, it
// includes the ability to statically enable pipeline and/or bypass
// behavior. Pipeline behavior is when the deq_rdy signal is
// combinationally wired to the enq_rdy signal allowing elements to be
// dequeued and enqueued in the same cycle when the queue is full. Bypass
// behavior is when the enq_en signal is combinationally wired to the
// deq_rdy signal allowing elements to bypass the storage element if the
// storage element is empty.

module vc_QueueCtrl1
#(
  parameter p_type = `VC_QUEUE_NORMAL
)(
  input  logic clk,
  input  logic reset,

  input  logic recv_val,        // Enqueue data is valid
  output logic recv_rdy,        // Ready for producer to do an enqueue

  output logic send_val,         // Dequeue is called
  input  logic send_rdy,        // Consumer is ready to do a dequeue

  output logic write_en,       // Write en signal to wire up to storage element
  output logic bypass_mux_sel, // Used to control bypass mux for bypass queues
  output logic num_free_entries // Either zero or one
);

  // Status register

  logic full;
  logic full_next;

  always_ff @(posedge clk) begin
    full <= reset ? 1'b0 : full_next;
  end

  assign num_free_entries = full ? 1'b0 : 1'b1;

  // Determine if pipeline or bypass behavior is enabled

  localparam c_pipe_en   = |( p_type & `VC_QUEUE_PIPE   );
  localparam c_bypass_en = |( p_type & `VC_QUEUE_BYPASS );

  // We enq/deq only when the call is enabled

  logic  do_enq;
  assign do_enq = recv_rdy && recv_val;

  logic  do_deq;
  assign do_deq = send_rdy && send_val;

  // Determine if we have pipeline or bypass behaviour and
  // set the write enable accordingly.

  logic  empty;
  assign empty = ~full;

  logic  do_pipe;
  assign do_pipe = c_pipe_en   && full  && do_enq && do_deq;

  logic  do_bypass;
  assign do_bypass = c_bypass_en && empty && do_enq && do_deq;

  assign write_en = do_enq && ~do_bypass;

  // Regardless of the type of queue or whether or not we are actually
  // doing a bypass, if the queue is empty then we select the enq bits,
  // otherwise we select the output of the queue state elements.

  assign bypass_mux_sel = empty;

  // Ready signals are calculated from full register. If pipeline
  // behavior is enabled, then the recv_rdy signal is also calculated
  // combinationally from the send_rdy signal. If bypass behavior is
  // enabled then the deq_val signal is also calculated combinationally
  // from the enq_val signal.

  assign recv_rdy  = ~full  || ( c_pipe_en   && full  && send_rdy );
  assign send_val  = ~empty || ( c_bypass_en && empty && recv_val );

  // Control logic for the full register input

  assign full_next = ( do_deq && ~do_pipe )   ? 1'b0
                   : ( do_enq && ~do_bypass ) ? 1'b1
                   :                            full;

endmodule

//------------------------------------------------------------------------
// Single-Element Queue Datapath
//------------------------------------------------------------------------
// This is the datpath for single element queues. It includes a register
// and a bypass mux if needed.

module vc_QueueDpath1
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 1
)(
  input  logic                   clk,
  input  logic                   reset,
  input  logic                   write_en,
  input  logic                   bypass_mux_sel,
  input  logic [p_msg_nbits-1:0] recv_msg,
  output logic [p_msg_nbits-1:0] send_msg
);

  // Queue storage

  logic [p_msg_nbits-1:0] qstore;

  vc_EnReg#(p_msg_nbits) qstore_reg
  (
    .clk   (clk),
    .reset (reset),
    .en    (write_en),
    .d     (recv_msg),
    .q     (qstore)
  );

  // Bypass muxing

  generate
  if ( |(p_type & `VC_QUEUE_BYPASS ) )

    vc_Mux2#(p_msg_nbits) bypass_mux
    (
      .in0 (qstore),
      .in1 (recv_msg),
      .sel (bypass_mux_sel),
      .out (send_msg)
    );

  else
    assign send_msg = qstore;
  endgenerate

endmodule

//------------------------------------------------------------------------
// Multi-Element Queue Control Logic
//------------------------------------------------------------------------
// This is the control logic for a multi-elment queue. It is designed to
// be attached to a Regfile storage element. Additionally, it includes
// the ability to statically enable pipeline and/or bypass behavior.
// Pipeline behavior is when the send_rdy signal is combinationally wired
// to the recv_rdy signal allowing elements to be dequeued and enqueued in
// the same cycle when the queue is full. Bypass behavior is when the
// recv_val signal is cominationally wired to the send_val signal allowing
// elements to bypass the storage element if the storage element is
// empty.

module vc_QueueCtrl
#(
  parameter p_type     = `VC_QUEUE_NORMAL,
  parameter p_num_msgs = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                    clk, reset,

  input  logic                    recv_val,        // Enqueue is valid
  output logic                    recv_rdy,        // Ready for producer to enqueue

  output logic                    send_val,        // Dequeue is called
  input  logic                    send_rdy,        // Consumer is ready to dequeue

  output logic                    write_en,       // Wen to wire to regfile
  output logic [c_addr_nbits-1:0] write_addr,     // Waddr to wire to regfile
  output logic [c_addr_nbits-1:0] read_addr,      // Raddr to wire to regfile
  output logic                    bypass_mux_sel, // Control mux for bypass queues
  output logic [c_addr_nbits:0]   num_free_entries // Num of free entries in queue
);

  // Enqueue and dequeue pointers

  logic [c_addr_nbits-1:0] enq_ptr;
  logic [c_addr_nbits-1:0] enq_ptr_next;

  vc_ResetReg#(c_addr_nbits) enq_ptr_reg
  (
    .clk     (clk),
    .reset   (reset),
    .d       (enq_ptr_next),
    .q       (enq_ptr)
  );

  logic [c_addr_nbits-1:0] deq_ptr;
  logic [c_addr_nbits-1:0] deq_ptr_next;

  vc_ResetReg#(c_addr_nbits) deq_ptr_reg
  (
    .clk   (clk),
    .reset (reset),
    .d     (deq_ptr_next),
    .q     (deq_ptr)
  );

  assign write_addr = enq_ptr;
  assign read_addr  = deq_ptr;

  // Extra state to tell difference between full and empty

  logic full;
  logic full_next;

  vc_ResetReg#(1) full_reg
  (
    .clk   (clk),
    .reset (reset),
    .d     (full_next),
    .q     (full)
  );

  // Determine if pipeline or bypass behavior is enabled

  localparam c_pipe_en   = |( p_type & `VC_QUEUE_PIPE   );
  localparam c_bypass_en = |( p_type & `VC_QUEUE_BYPASS );

  // We enq/deq only when they are both ready and valid

  logic  do_enq;
  assign do_enq = recv_rdy && recv_val;

  logic  do_deq;
  assign do_deq = send_rdy && send_val;

  // Determine if we have pipeline or bypass behaviour and
  // set the write enable accordingly.

  logic  empty;
  assign empty = ~full && (enq_ptr == deq_ptr);

  logic  do_pipe;
  assign do_pipe = c_pipe_en && full  && do_enq && do_deq;

  logic  do_bypass;
  assign do_bypass = c_bypass_en && empty && do_enq && do_deq;

  assign write_en = do_enq && ~do_bypass;

  // Regardless of the type of queue or whether or not we are actually
  // doing a bypass, if the queue is empty then we select the enq bits,
  // otherwise we select the output of the queue state elements.

  assign bypass_mux_sel = empty;

  // Ready signals are calculated from full register. If pipeline
  // behavior is enabled, then the recv_rdy signal is also calculated
  // combinationally from the send_rdy signal. If bypass behavior is
  // enabled then the send_val signal is also calculated combinationally
  // from the recv_val signal.

  assign recv_rdy = ~full  || ( c_pipe_en   && full  && send_rdy );
  assign send_val = ~empty || ( c_bypass_en && empty && recv_val );

  // Control logic for the enq/deq pointers and full register

  logic [c_addr_nbits-1:0] deq_ptr_plus1;
  assign deq_ptr_plus1 = deq_ptr + 1'b1;

  /* verilator lint_off WIDTH */

  logic [c_addr_nbits-1:0] deq_ptr_inc;
  assign deq_ptr_inc = (deq_ptr_plus1 == p_num_msgs) ? {c_addr_nbits{1'b0}} : deq_ptr_plus1;

  logic [c_addr_nbits-1:0] enq_ptr_plus1;
  assign enq_ptr_plus1 = enq_ptr + 1'b1;

  logic [c_addr_nbits-1:0] enq_ptr_inc;
  assign enq_ptr_inc = (enq_ptr_plus1 == p_num_msgs) ? {c_addr_nbits{1'b0}} : enq_ptr_plus1;

  /* verilator lint_on WIDTH */

  assign deq_ptr_next
    = ( do_deq && ~do_bypass ) ? ( deq_ptr_inc ) : deq_ptr;

  assign enq_ptr_next
    = ( do_enq && ~do_bypass ) ? ( enq_ptr_inc ) : enq_ptr;

  assign full_next
    = ( do_enq && ~do_deq && ( enq_ptr_inc == deq_ptr ) ) ? 1'b1
    : ( do_deq && full && ~do_pipe )                      ? 1'b0
    :                                                       full;

  // Number of free entries

  assign num_free_entries
    = full                ? {(c_addr_nbits+1){1'b0}}
    : empty               ? p_num_msgs[c_addr_nbits:0]
    : (enq_ptr > deq_ptr) ? p_num_msgs[c_addr_nbits:0] - (enq_ptr - deq_ptr)
    : (deq_ptr > enq_ptr) ? deq_ptr - enq_ptr
    :                       {(c_addr_nbits+1){1'bx}};

endmodule

//------------------------------------------------------------------------
// Multi-Element Queue Datapath
//------------------------------------------------------------------------
// This is the datpath for multi-element queues. It includes a register
// and a bypass mux if needed.

module vc_QueueDpath
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 4,
  parameter p_num_msgs  = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                    clk,
  input  logic                    reset,
  input  logic                    write_en,
  input  logic                    bypass_mux_sel,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [c_addr_nbits-1:0] read_addr,
  input  logic [p_msg_nbits-1:0]  recv_msg,
  output logic [p_msg_nbits-1:0]  send_msg
);

  // Queue storage

  logic [p_msg_nbits-1:0] read_data;

  vc_Regfile_1r1w#(p_msg_nbits,p_num_msgs) qstore
  (
    .clk        (clk),
    .reset      (reset),
    .read_addr  (read_addr),
    .read_data  (read_data),
    .write_en   (write_en),
    .write_addr (write_addr),
    .write_data (recv_msg)
  );

  // Bypass muxing

  generate
  if ( |(p_type & `VC_QUEUE_BYPASS ) )

    vc_Mux2#(p_msg_nbits) bypass_mux
    (
      .in0 (read_data),
      .in1 (recv_msg),
      .sel (bypass_mux_sel),
      .out (send_msg)
    );

  else
    assign send_msg = read_data;
  endgenerate

endmodule

//------------------------------------------------------------------------
// Queue
//------------------------------------------------------------------------

module vc_Queue
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 1,
  parameter p_num_msgs  = 2,

  // parameters not meant to be set outside this module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                   clk,
  input  logic                   reset,

  input  logic                   recv_val,
  output logic                   recv_rdy,
  input  logic [p_msg_nbits-1:0] recv_msg,

  output logic                   send_val,
  input  logic                   send_rdy,
  output logic [p_msg_nbits-1:0] send_msg,

  output logic [c_addr_nbits:0]  num_free_entries
);


  generate
  if ( p_num_msgs == 1 )
  begin

    logic write_en;
    logic bypass_mux_sel;

    vc_QueueCtrl1#(p_type) ctrl
    (
      .clk              (clk),
      .reset            (reset),
      .recv_val         (recv_val),
      .recv_rdy         (recv_rdy),
      .send_val         (send_val),
      .send_rdy         (send_rdy),
      .write_en         (write_en),
      .bypass_mux_sel   (bypass_mux_sel),
      .num_free_entries (num_free_entries)
    );

    vc_QueueDpath1#(p_type,p_msg_nbits) dpath
    (
      .clk            (clk),
      .reset          (reset),
      .write_en       (write_en),
      .bypass_mux_sel (bypass_mux_sel),
      .recv_msg       (recv_msg),
      .send_msg       (send_msg)
    );

  end
  else
  begin

    logic                    write_en;
    logic                    bypass_mux_sel;
    logic [c_addr_nbits-1:0] write_addr;
    logic [c_addr_nbits-1:0] read_addr;

    vc_QueueCtrl#(p_type,p_num_msgs) ctrl
    (
      .clk              (clk),
      .reset            (reset),
      .recv_val         (recv_val),
      .recv_rdy         (recv_rdy),
      .send_val         (send_val),
      .send_rdy         (send_rdy),
      .write_en         (write_en),
      .write_addr       (write_addr),
      .read_addr        (read_addr),
      .bypass_mux_sel   (bypass_mux_sel),
      .num_free_entries (num_free_entries)
    );

    vc_QueueDpath#(p_type,p_msg_nbits,p_num_msgs) dpath
    (
      .clk              (clk),
      .reset            (reset),
      .write_en         (write_en),
      .bypass_mux_sel   (bypass_mux_sel),
      .write_addr       (write_addr),
      .read_addr        (read_addr),
      .recv_msg         (recv_msg),
      .send_msg         (send_msg)
    );

  end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( enq_en  );
      `VC_ASSERT_NOT_X( enq_rdy );
      `VC_ASSERT_NOT_X( deq_en  );
      `VC_ASSERT_NOT_X( deq_rdy );
    end
  end
  */

  // Line Tracing

  //  logic [`VC_TRACE_NBITS_TO_NCHARS(p_msg_nbits)*8-1:0] str;
  //
  //  `VC_TRACE_BEGIN
  //  begin
  //
  //    $sformat( str, "%x", enq_msg );
  //    vc_trace.append_en_rdy_str( trace_str, enq_en, enq_rdy, str );
  //
  //    vc_trace.append_str( trace_str, "(" );
  //    $sformat( str, "%x", p_num_msgs-num_free_entries );
  //    vc_trace.append_str( trace_str, str );
  //    vc_trace.append_str( trace_str, ")" );
  //
  //    $sformat( str, "%x", deq_msg );
  //    vc_trace.append_en_rdy_str( trace_str, deq_en, deq_rdy, str );

  // end
  // endtask

endmodule

`endif /* VC_QUEUES_V */
`line 13 "../../../spi_minion/sim/SPI_minion/components/SPIMinionAdapterVRTL.v" 0

module SPI_minion_components_SPIMinionAdapterVRTL
#(
  parameter nbits = 8,
  parameter num_entries = 1
)
(
  input  logic                    clk,
  input  logic                    reset,
  input  logic                    pull_en,
  output logic                    pull_msg_val,
  output logic                    pull_msg_spc,
  output logic [nbits-3:0]        pull_msg_data,
  input  logic                    push_en,
  input  logic                    push_msg_val_wrt,
  input  logic                    push_msg_val_rd,
  input  logic [nbits-3:0]        push_msg_data,
  input  logic [nbits-3:0]        recv_msg,
  output logic                    recv_rdy,
  input  logic                    recv_val,
  output logic [nbits-3:0]        send_msg,
  input  logic                    send_rdy,
  output logic                    send_val,
  output logic                    parity  
);

  logic open_entries;

  logic [nbits-3:0]             cm_q_send_msg;
  logic                         cm_q_send_rdy;
  logic                         cm_q_send_val;

  vc_Queue #(4'b0, nbits-2, num_entries) cm_q
  (
    .clk( clk ),
    .num_free_entries( ),
    .reset( reset ),
    .recv_msg( recv_msg ),
    .recv_rdy( recv_rdy ),
    .recv_val( recv_val ),
    .send_msg( cm_q_send_msg ),
    .send_rdy( cm_q_send_rdy ),
    .send_val( cm_q_send_val )
  );

  logic [$clog2(num_entries):0] mc_q_num_free;
  logic                         mc_q_recv_rdy;
  logic                         mc_q_recv_val;

  vc_Queue #(4'b0, nbits-2, num_entries) mc_q
  (
    .clk( clk ),
    .num_free_entries( mc_q_num_free ),
    .reset( reset ),
    .recv_msg( push_msg_data ),
    .recv_rdy( mc_q_recv_rdy ),
    .recv_val( mc_q_recv_val ),
    .send_msg( send_msg ),
    .send_rdy( send_rdy ),
    .send_val( send_val )
  );

  assign parity = (^send_msg) & send_val;
  
  always_comb begin : comb_block
    open_entries  = mc_q_num_free > 1;
    mc_q_recv_val = push_msg_val_wrt & push_en;
    pull_msg_spc  = mc_q_recv_rdy & ( ( ~mc_q_recv_val ) | open_entries );
    cm_q_send_rdy = push_msg_val_rd & pull_en;
    pull_msg_val  = cm_q_send_rdy & cm_q_send_val;
    pull_msg_data = cm_q_send_msg & { (nbits-2){pull_msg_val} };
  end

endmodule

`endif /* SPI_V3_COMPONENTS_MINION_ADAPTER_V */
`line 3 "../../../spi_minion/sim/SPI_minion/components/SPIMinionAdapterConnectedVRTL.v" 0

module SPIMinionAdapterConnectedVRTL
#(
    BIT_WIDTH  = 32,
    N_SAMPLES  = 8
)
(
    input  logic                    clk,
    input  logic                    reset,
    input  logic                    cs,
    input  logic                    sclk,
    input  logic                    mosi,
    output logic                    miso,
    input  logic [BIT_WIDTH - 1:0]  recv_msg,
    output logic                    recv_rdy,
    input  logic                    recv_val,
    output logic [BIT_WIDTH - 1:0]  send_msg,
    input  logic                    send_rdy,
    output logic                    send_val,
    output logic                    minion_parity,
    output logic                    adapter_parity
);

logic                    push_en;
logic                    pull_en;

logic [BIT_WIDTH + 1:0]  push_msg;
logic [BIT_WIDTH - 1:0]  pull_msg;
logic                    pull_msg_val;
logic                    pull_msg_spc;

SPI_minion_components_SPIMinionVRTL #(.nbits(BIT_WIDTH+2)) minion
(
    .clk(clk),
    .cs(cs),
    .miso(miso),
    .mosi(mosi),
    .reset(reset),
    .sclk(sclk),
    .pull_en(pull_en),
    .pull_msg({pull_msg_val, pull_msg_spc, pull_msg}),
    .push_en(push_en),
    .push_msg(push_msg),  
    .parity(minion_parity)
);

SPI_minion_components_SPIMinionAdapterVRTL #(.nbits(BIT_WIDTH+2), .num_entries(N_SAMPLES)) adapter1
(
    .clk(clk),
    .reset(reset),
    .pull_en(pull_en),
    .pull_msg_val(pull_msg_val),
    .pull_msg_spc(pull_msg_spc),
    .pull_msg_data(pull_msg),
    .push_en(push_en),
    .push_msg_val_wrt(push_msg[BIT_WIDTH + 1]),
    .push_msg_val_rd(push_msg[BIT_WIDTH]),
    .push_msg_data(push_msg[BIT_WIDTH - 1:0]),  
    .recv_msg(recv_msg),
    .recv_val(recv_val),
    .recv_rdy(recv_rdy),

    .send_msg(send_msg),
    .send_val(send_val),
    .send_rdy(send_rdy),
    .parity(adapter_parity)
);

endmodule

`line 6 "tape_in_FFT_interconnectVRTL.v" 0
`line 1 "../../../tape_in_sim/sim/minion_FFT/FFTSPIMinionVRTL.v" 0
`ifndef FFT_SPI_MINION_VRTL
`define FFT_SPI_MINION_VRTL
`line 1 "../../../spi_minion/sim/SPI_minion/components/SPIMinionVRTL.v" 0
// ==========================================================================
// SPIMinionVRTL.v
// ==========================================================================
// SPIMinion module. Supports SPI mode 0

// Author : Yanghui Ou, Modified by Kyle Infantino

`ifndef SPI_MINION_COMPONENTS_MINION_V
`define SPI_MINION_COMPONENTS_MINION_V

`line 1 "../../../spi_minion/sim/SPI_minion/components/ShiftReg.v" 0
/*
==========================================================================
ShiftReg.v
==========================================================================
N-bit shift register.
*/

`ifndef SPI_MINION_COMPONENTS_SHIFTREG_V
`define SPI_MINION_COMPONENTS_SHIFTREG_V

module SPI_minion_components_ShiftReg
#(
    parameter nbits = 8,
    parameter reset_value = 1'b0
)
(
  input  logic             clk,
  input  logic             in_,
  input  logic [nbits-1:0] load_data,
  input  logic             load_en,
  output logic [nbits-1:0] out,
  input  logic             reset,
  input  logic             shift_en 
);
  
  always_ff @(posedge clk) begin 
    if ( reset ) begin
      out <= { nbits{reset_value}};
    end else if ( load_en ) begin
      out <= load_data;
    end else if ( ( ~load_en ) & shift_en ) begin
      out <= { out[nbits-2:0], in_ };
    end
  end

endmodule

`endif /* SPI_MINION_COMPONENTS_SHIFTREG_V */
`line 12 "../../../spi_minion/sim/SPI_minion/components/SPIMinionVRTL.v" 0
`line 1 "../../../spi_minion/sim/SPI_minion/components/Synchronizer.v" 0
/*
==========================================================================
Synchronizer.v
==========================================================================
 - RTL code for the Synchronizer module.
 - It samples the input signal using the device clock and also detects
     positive and negative edges.
 - Reference: https://www.fpga4fun.com/SPI2.html
*/

`ifndef SPI_MINION_COMPONENTS_SYNCHRONIZER_V
`define SPI_MINION_COMPONENTS_SYNCHRONIZER_V

module SPI_minion_components_Synchronizer 
#(
  parameter reset_value = 1'b0
)(
  input  logic clk ,
  input  logic in_,
  output logic negedge_,
  output logic out,
  output logic posedge_,
  input  logic reset 
);

  logic [2:0] shreg;
  
  always_comb begin
    negedge_ = shreg[2] & ( ~shreg[1] );
    posedge_ = ( ~shreg[2] ) & shreg[1];
  end
  
  always_ff @(posedge clk) begin
    if ( reset ) begin
      shreg <= { 3{reset_value} };
    end
    else
      shreg <= { shreg[1:0], in_ };
  end

  assign out = shreg[1];

endmodule

`endif /* SPI_MINION_COMPONENTS_SYNCHRONIZER_V */
`line 13 "../../../spi_minion/sim/SPI_minion/components/SPIMinionVRTL.v" 0

module SPI_minion_components_SPIMinionVRTL
#(
  parameter nbits = 8
)
(
  input  logic             clk,
  input  logic             cs,
  output logic             miso,
  input  logic             mosi,
  input  logic             reset,
  input  logic             sclk,
  output logic             pull_en,
  input  logic [nbits-1:0] pull_msg,
  output logic             push_en,
  output logic [nbits-1:0] push_msg,  
  output logic             parity
);
  //-------------------------------------------------------------
  // Component cs_sync
  //-------------------------------------------------------------

  logic cs_sync_clk;
  logic cs_sync_in_;
  logic cs_sync_negedge_;
  logic cs_sync_out;
  logic cs_sync_posedge_;
  logic cs_sync_reset;

  SPI_minion_components_Synchronizer #(1'b1) cs_sync
  (
    .clk( cs_sync_clk ),
    .in_( cs_sync_in_ ),
    .negedge_( cs_sync_negedge_ ),
    .out( cs_sync_out ),
    .posedge_( cs_sync_posedge_ ),
    .reset( cs_sync_reset )
  );

  //-------------------------------------------------------------
  // Component mosi_sync
  //-------------------------------------------------------------

  logic mosi_sync_clk;
  logic mosi_sync_in_;
  logic mosi_sync_negedge_;
  logic mosi_sync_out;
  logic mosi_sync_posedge_;
  logic mosi_sync_reset;

  SPI_minion_components_Synchronizer #(1'b0) mosi_sync
  (
    .clk( mosi_sync_clk ),
    .in_( mosi_sync_in_ ),
    .negedge_( mosi_sync_negedge_ ),
    .out( mosi_sync_out ),
    .posedge_( mosi_sync_posedge_ ),
    .reset( mosi_sync_reset )
  );

  //-------------------------------------------------------------
  // Component sclk_sync
  //-------------------------------------------------------------

  logic sclk_sync_clk;
  logic sclk_sync_in_;
  logic sclk_sync_negedge_;
  logic sclk_sync_out;
  logic sclk_sync_posedge_;
  logic sclk_sync_reset;

  SPI_minion_components_Synchronizer #(1'b0) sclk_sync
  (
    .clk( sclk_sync_clk ),
    .in_( sclk_sync_in_ ),
    .negedge_( sclk_sync_negedge_ ),
    .out( sclk_sync_out ),
    .posedge_( sclk_sync_posedge_ ),
    .reset( sclk_sync_reset )
  );

  //-------------------------------------------------------------
  // Component shreg_in
  //-------------------------------------------------------------

  logic             shreg_in_clk;
  logic             shreg_in_in_;
  logic [nbits-1:0] shreg_in_load_data;
  logic             shreg_in_load_en;
  logic [nbits-1:0] shreg_in_out;
  logic             shreg_in_reset;
  logic             shreg_in_shift_en;

  SPI_minion_components_ShiftReg #( nbits ) shreg_in
  (
    .clk( shreg_in_clk ),
    .in_( shreg_in_in_ ),
    .load_data( shreg_in_load_data ),
    .load_en( shreg_in_load_en ),
    .out( shreg_in_out ),
    .reset( shreg_in_reset ),
    .shift_en( shreg_in_shift_en )
  );

  //-------------------------------------------------------------
  // Component shreg_out
  //-------------------------------------------------------------

  logic             shreg_out_clk;
  logic             shreg_out_in_;
  logic [nbits-1:0] shreg_out_load_data;
  logic             shreg_out_load_en;
  logic [nbits-1:0] shreg_out_out;
  logic             shreg_out_reset;
  logic             shreg_out_shift_en;

  SPI_minion_components_ShiftReg #( nbits ) shreg_out
  (
    .clk( shreg_out_clk ),
    .in_( shreg_out_in_ ),
    .load_data( shreg_out_load_data ),
    .load_en( shreg_out_load_en ),
    .out( shreg_out_out ),
    .reset( shreg_out_reset ),
    .shift_en( shreg_out_shift_en )
  );
  
  always_comb begin
    shreg_in_shift_en = ( ~cs_sync_out ) & sclk_sync_posedge_;
    shreg_out_shift_en = ( ~cs_sync_out ) & sclk_sync_negedge_;
  end

  assign cs_sync_clk         = clk;
  assign cs_sync_reset       = reset;
  assign cs_sync_in_         = cs;
  assign sclk_sync_clk       = clk;
  assign sclk_sync_reset     = reset;
  assign sclk_sync_in_       = sclk;
  assign mosi_sync_clk       = clk;
  assign mosi_sync_reset     = reset;
  assign mosi_sync_in_       = mosi;
  assign shreg_in_clk        = clk;
  assign shreg_in_reset      = reset;
  assign shreg_in_in_        = mosi_sync_out;
  assign shreg_in_load_en    = 1'b0;
  assign shreg_in_load_data  = {nbits{1'b0}};
  assign shreg_out_clk       = clk;
  assign shreg_out_reset     = reset;
  assign shreg_out_in_       = 1'b0;
  assign shreg_out_load_en   = pull_en;
  assign shreg_out_load_data = pull_msg;
  assign miso                = shreg_out_out[nbits-1];
  assign pull_en             = cs_sync_negedge_;
  assign push_en             = cs_sync_posedge_;
  assign push_msg            = shreg_in_out;
  assign parity              = (^push_msg[nbits-3:0]) & push_en;

endmodule

`endif /* SPI_MINION_COMPONENTS_MINION_V */
`line 4 "../../../tape_in_sim/sim/minion_FFT/FFTSPIMinionVRTL.v" 0
`line 1 "../../../spi_minion/sim/SPI_minion/components/SPIMinionAdapterVRTL.v" 0
// ==========================================================================
// SPIMinionAdapterVRTL.v
// ==========================================================================
// An Adapter that converts push/pull interface from SPI to val/rdy interfaces. 

// Author : Kyle Infantino
// Date : Nov 30, 2021

`ifndef SPI_MINION_COMPONENTS_MINION_ADAPTER_V
`define SPI_MINION_COMPONENTS_MINION_ADAPTER_V

`line 1 "../../../spi_minion/sim/vc/queues.v" 0
//========================================================================
// Verilog Components: Queues
//========================================================================

`ifndef VC_QUEUES_V
`define VC_QUEUES_V

`line 1 "../../../spi_minion/sim/vc/regs.v" 0
//========================================================================
// Verilog Components: Registers
//========================================================================

// Note that we place the register output earlier in the port list since
// this is one place we might actually want to use positional port
// binding like this:
//
//  logic [p_nbits-1:0] result_B;
//  vc_Reg#(p_nbits) result_AB( clk, result_B, result_A );

`ifndef VC_REGS_V
`define VC_REGS_V

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop
//------------------------------------------------------------------------

module vc_Reg
#(
  parameter p_nbits = 1
)(
  input  logic               clk, // Clock input
  output logic [p_nbits-1:0] q,   // Data output
  input  logic [p_nbits-1:0] d    // Data input
);

  always_ff @( posedge clk )
    q <= d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with reset
//------------------------------------------------------------------------

module vc_ResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d      // Data input
);

  always_ff @( posedge clk )
    q <= reset ? p_reset_value : d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable
//------------------------------------------------------------------------

module vc_EnReg
#(
  parameter p_nbits = 1
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( en )
      q <= d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable and reset
//------------------------------------------------------------------------

module vc_EnResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( reset || en )
      q <= reset ? p_reset_value : d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

`endif /* VC_REGS_V */
`line 9 "../../../spi_minion/sim/vc/queues.v" 0
`line 1 "../../../spi_minion/sim/vc/muxes.v" 0
//========================================================================
// Verilog Components: Muxes
//========================================================================

`ifndef VC_MUXES_V
`define VC_MUXES_V

//------------------------------------------------------------------------
// 2 Input Mux
//------------------------------------------------------------------------

module vc_Mux2
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1,
  input  logic               sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      1'd0 : out = in0;
      1'd1 : out = in1;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 3 Input Mux
//------------------------------------------------------------------------

module vc_Mux3
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 4 Input Mux
//------------------------------------------------------------------------

module vc_Mux4
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      2'd3 : out = in3;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 5 Input Mux
//------------------------------------------------------------------------

module vc_Mux5
#(
 parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 6 Input Mux
//------------------------------------------------------------------------

module vc_Mux6
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 7 Input Mux
//------------------------------------------------------------------------

module vc_Mux7
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 8 Input Mux
//------------------------------------------------------------------------

module vc_Mux8
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6, in7,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always @(*)
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      3'd7 : out = in7;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// N Input Mux
//------------------------------------------------------------------------

module vc_MuxN
#(
  parameter p_nbits = 1,
  parameter p_ninputs = 2
)(
  input  logic [p_ninputs-1:0][p_nbits-1:0] in,
  input  logic [$clog2(p_ninputs)-1:0]      sel,
  output logic [p_nbits-1:0]                out
);

  assign out = in[sel];

endmodule

`endif /* VC_MUXES_V */
`line 10 "../../../spi_minion/sim/vc/queues.v" 0
`line 1 "../../../spi_minion/sim/vc/regfiles.v" 0
//========================================================================
// Verilog Components: Register Files
//========================================================================

`ifndef VC_REGFILES_V
`define VC_REGFILES_V

//------------------------------------------------------------------------
// 1r1w register file
//------------------------------------------------------------------------

module vc_Regfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );
      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.
      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end
    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 1r1w register file with reset
//------------------------------------------------------------------------

module vc_ResetRegfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,
  parameter p_reset_value = 0,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge. We have to use a generate statement to
  // allow us to include the reset logic for each individual register.

  genvar i;
  generate
    for ( i = 0; i < p_num_entries; i = i+1 )
    begin : wport
      always_ff @( posedge clk )
        if ( reset )
          rfile[i] <= p_reset_value;
        else if ( write_en && (i[c_addr_nbits-1:0] == write_addr) )
          rfile[i] <= write_data;
    end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );
      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.
      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end
    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r1w register file
//------------------------------------------------------------------------

module vc_Regfile_2r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                   clk,
  input  logic                   reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );
      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.
      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end
    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r2w register file
//------------------------------------------------------------------------

module vc_Regfile_2r2w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en0,
  input  logic [c_addr_nbits-1:0] write_addr0,
  input  logic [p_data_nbits-1:0] write_data0,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en1,
  input  logic [c_addr_nbits-1:0] write_addr1,
  input  logic [p_data_nbits-1:0] write_data1
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk ) begin

    if ( write_en0 )
      rfile[write_addr0] <= write_data0;

    if ( write_en1 )
      rfile[write_addr1] <= write_data1;

  end

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en0 );
      `VC_ASSERT_NOT_X( write_en1 );
      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.
      if ( write_en0 ) begin
        `VC_ASSERT_NOT_X( write_addr0 );
        `VC_ASSERT( write_addr0 < p_num_entries );
      end
      if ( write_en1 ) begin
        `VC_ASSERT_NOT_X( write_addr1 );
        `VC_ASSERT( write_addr1 < p_num_entries );
      end
      // It is invalid to use the same write address for both write ports
      if ( write_en0 && write_en1 ) begin
        `VC_ASSERT( write_addr0 != write_addr1 );
      end
    end
  end
  */

endmodule

//------------------------------------------------------------------------
// Register file specialized for r0 == 0
//------------------------------------------------------------------------

module vc_Regfile_2r1w_zero
(
  input  logic        clk,
  input  logic        reset,

  input  logic  [4:0] rd_addr0,
  output logic [31:0] rd_data0,

  input  logic  [4:0] rd_addr1,
  output logic [31:0] rd_data1,

  input  logic        wr_en,
  input  logic  [4:0] wr_addr,
  input  logic [31:0] wr_data
);

  // these wires are to be hooked up to the actual register file read
  // ports

  logic [31:0] rf_read_data0;
  logic [31:0] rf_read_data1;

  vc_Regfile_2r1w
  #(
    .p_data_nbits  (32),
    .p_num_entries (32)
  )
  rfile
  (
    .clk         (clk),
    .reset       (reset),
    .read_addr0  (rd_addr0),
    .read_data0  (rf_read_data0),
    .read_addr1  (rd_addr1),
    .read_data1  (rf_read_data1),
    .write_en    (wr_en),
    .write_addr  (wr_addr),
    .write_data  (wr_data)
  );

  // we pick 0 value when either read address is 0
  assign rd_data0 = ( rd_addr0 == 5'd0 ) ? 32'd0 : rf_read_data0;
  assign rd_data1 = ( rd_addr1 == 5'd0 ) ? 32'd0 : rf_read_data1;

endmodule

`endif /* VC_REGFILES_V */
`line 11 "../../../spi_minion/sim/vc/queues.v" 0
`line 1 "../../../spi_minion/sim/vc/trace.v" 0
//========================================================================
// Line Tracing
//========================================================================

`ifndef VC_TRACE_V
`define VC_TRACE_V

// NOTE: This macro is declared outside of the module to allow some vc
// modules to see it and use it in their own params. Verilog does not
// allow other modules to hierarchically reference the nbits localparam
// inside this module in constant expressions (e.g., localparams).

`define VC_TRACE_NCHARS 512
`define VC_TRACE_NBITS  512*8

`ifndef SYNTHESIS

module vc_Trace
(
  input logic clk,
  input logic reset
);

  integer len0;
  integer len1;
  integer idx0;
  integer idx1;

  // NOTE: If you change these, then you also need to change the
  // hard-coded constant in the declaration of the trace function at the
  // bottom of this file.
  // NOTE: You would also need to change the VC_TRACE_NBITS and
  // VC_TRACE_NCHARS macro at the top of this file.

  localparam nchars = 512;
  localparam nbits  = 512*8;

  // This is the actual trace storage used when displaying a trace

  logic [nbits-1:0] storage;

  // Meant to be accesible from outside module

  integer cycles_next = 0;
  integer cycles      = 0;

  // Get trace level from command line

  logic [3:0] level;

`ifndef VERILATOR
  initial begin
    if ( !$value$plusargs( "trace=%d", level ) ) begin
      level = 0;
    end
  end
`else
  initial begin
    level = 1;
  end
`endif // !`ifndef VERILATOR

  // Track cycle count

  always_ff @( posedge clk ) begin
    cycles <= ( reset ) ? 0 : cycles_next;
  end

  //----------------------------------------------------------------------
  // append_str
  //----------------------------------------------------------------------
  // Appends a string to the trace.

  task append_str
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    len0 = 1;
    while ( str[len0*8+:8] != 0 ) begin
      len0 = len0 + 1;
    end

    idx0 = trace[31:0];

    for ( idx1 = len0-1; idx1 >= 0; idx1 = idx1 - 1 )
    begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8 +: 8 ];
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_str_ljust
  //----------------------------------------------------------------------
  // Appends a left-justified string to the trace.

  task append_str_ljust
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    idx0 = trace[31:0];
    idx1 = nchars;

    while ( str[ idx1*8-1 -: 8 ] != 0 ) begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8-1 -: 8 ];
      idx0 = idx0 - 1;
      idx1 = idx1 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_chars
  //----------------------------------------------------------------------
  // Appends the given number of characters to the trace.

  task append_chars
  (
    inout logic   [nbits-1:0] trace,
    input logic         [7:0] char,
    input integer             num
  );
  begin

    idx0 = trace[31:0];

    for ( idx1 = 0;
          idx1 < num;
          idx1 = idx1 + 1 )
    begin
      trace[idx0*8+:8] = char;
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_val_str
  //----------------------------------------------------------------------
  // Append a string modified by val signal.

  task append_val_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val )
      append_str( trace, str );
    else if ( !val )
      append_chars( trace, " ", len1 );
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

  //----------------------------------------------------------------------
  // val_rdy_str
  //----------------------------------------------------------------------
  // Append a string modified by val/rdy signals.

  task append_val_rdy_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic             rdy,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val & rdy ) begin
      append_str( trace, str );
    end
    else if ( rdy && !val ) begin
      append_chars( trace, " ", len1 );
    end
    else if ( !rdy && !val ) begin
      append_str( trace, "." );
      append_chars( trace, " ", len1-1 );
    end
    else if ( !rdy && val ) begin
      append_str( trace, "#" );
      append_chars( trace, " ", len1-1 );
    end
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

endmodule

`endif /* SYNTHESIS */

//------------------------------------------------------------------------
// VC_TRACE_NBITS_TO_NCHARS
//------------------------------------------------------------------------
// Macro to determine number of characters for a net

`define VC_TRACE_NBITS_TO_NCHARS( nbits_ ) ((nbits_+3)/4)

//------------------------------------------------------------------------
// VC_TRACE_BEGIN
//------------------------------------------------------------------------

//`define VC_TRACE_BEGIN                                                  \
//  export "DPI-C" task line_trace;                                       \
//  vc_Trace vc_trace(clk,reset);                                         \
//  task line_trace( inout bit [(512*8)-1:0] trace_str );

`ifndef VERILATOR
`define VC_TRACE_BEGIN                                                  \
  vc_Trace vc_trace(clk,reset);                                         \
                                                                        \
  task display_trace;                                                   \
  begin                                                                 \
                                                                        \
    if ( vc_trace.level > 0 ) begin                                     \
      vc_trace.storage[15:0] = vc_trace.nchars-1;                       \
                                                                        \
      line_trace( vc_trace.storage );                                   \
                                                                        \
      $write( "%4d: ", vc_trace.cycles );                               \
                                                                        \
      vc_trace.idx0 = vc_trace.storage[15:0];                           \
      for ( vc_trace.idx1 = vc_trace.nchars-1;                          \
            vc_trace.idx1 > vc_trace.idx0;                              \
            vc_trace.idx1 = vc_trace.idx1 - 1 )                         \
      begin                                                             \
        $write( "%s", vc_trace.storage[vc_trace.idx1*8+:8] );           \
      end                                                               \
      $write("\n");                                                     \
                                                                        \
    end                                                                 \
                                                                        \
    vc_trace.cycles_next = vc_trace.cycles + 1;                         \
                                                                        \
  end                                                                   \
  endtask                                                               \
                                                                        \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`else
`define VC_TRACE_BEGIN                                                  \
  export "DPI-C" task line_trace;                                       \
  vc_Trace vc_trace(clk,reset);                                         \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`endif

//------------------------------------------------------------------------
// VC_TRACE_END
//------------------------------------------------------------------------

`define VC_TRACE_END \
  endtask

`endif /* VC_TRACE_V */
`line 12 "../../../spi_minion/sim/vc/queues.v" 0

//------------------------------------------------------------------------
// Defines
//------------------------------------------------------------------------

`define VC_QUEUE_NORMAL   4'b0000
`define VC_QUEUE_PIPE     4'b0001
`define VC_QUEUE_BYPASS   4'b0010

//------------------------------------------------------------------------
// Single-Element Queue Control Logic
//------------------------------------------------------------------------
// This is the control logic for a single-elment queue. It is designed to
// be attached to a storage element with a write enable. Additionally, it
// includes the ability to statically enable pipeline and/or bypass
// behavior. Pipeline behavior is when the deq_rdy signal is
// combinationally wired to the enq_rdy signal allowing elements to be
// dequeued and enqueued in the same cycle when the queue is full. Bypass
// behavior is when the enq_en signal is combinationally wired to the
// deq_rdy signal allowing elements to bypass the storage element if the
// storage element is empty.

module vc_QueueCtrl1
#(
  parameter p_type = `VC_QUEUE_NORMAL
)(
  input  logic clk,
  input  logic reset,

  input  logic recv_val,        // Enqueue data is valid
  output logic recv_rdy,        // Ready for producer to do an enqueue

  output logic send_val,         // Dequeue is called
  input  logic send_rdy,        // Consumer is ready to do a dequeue

  output logic write_en,       // Write en signal to wire up to storage element
  output logic bypass_mux_sel, // Used to control bypass mux for bypass queues
  output logic num_free_entries // Either zero or one
);

  // Status register

  logic full;
  logic full_next;

  always_ff @(posedge clk) begin
    full <= reset ? 1'b0 : full_next;
  end

  assign num_free_entries = full ? 1'b0 : 1'b1;

  // Determine if pipeline or bypass behavior is enabled

  localparam c_pipe_en   = |( p_type & `VC_QUEUE_PIPE   );
  localparam c_bypass_en = |( p_type & `VC_QUEUE_BYPASS );

  // We enq/deq only when the call is enabled

  logic  do_enq;
  assign do_enq = recv_rdy && recv_val;

  logic  do_deq;
  assign do_deq = send_rdy && send_val;

  // Determine if we have pipeline or bypass behaviour and
  // set the write enable accordingly.

  logic  empty;
  assign empty = ~full;

  logic  do_pipe;
  assign do_pipe = c_pipe_en   && full  && do_enq && do_deq;

  logic  do_bypass;
  assign do_bypass = c_bypass_en && empty && do_enq && do_deq;

  assign write_en = do_enq && ~do_bypass;

  // Regardless of the type of queue or whether or not we are actually
  // doing a bypass, if the queue is empty then we select the enq bits,
  // otherwise we select the output of the queue state elements.

  assign bypass_mux_sel = empty;

  // Ready signals are calculated from full register. If pipeline
  // behavior is enabled, then the recv_rdy signal is also calculated
  // combinationally from the send_rdy signal. If bypass behavior is
  // enabled then the deq_val signal is also calculated combinationally
  // from the enq_val signal.

  assign recv_rdy  = ~full  || ( c_pipe_en   && full  && send_rdy );
  assign send_val  = ~empty || ( c_bypass_en && empty && recv_val );

  // Control logic for the full register input

  assign full_next = ( do_deq && ~do_pipe )   ? 1'b0
                   : ( do_enq && ~do_bypass ) ? 1'b1
                   :                            full;

endmodule

//------------------------------------------------------------------------
// Single-Element Queue Datapath
//------------------------------------------------------------------------
// This is the datpath for single element queues. It includes a register
// and a bypass mux if needed.

module vc_QueueDpath1
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 1
)(
  input  logic                   clk,
  input  logic                   reset,
  input  logic                   write_en,
  input  logic                   bypass_mux_sel,
  input  logic [p_msg_nbits-1:0] recv_msg,
  output logic [p_msg_nbits-1:0] send_msg
);

  // Queue storage

  logic [p_msg_nbits-1:0] qstore;

  vc_EnReg#(p_msg_nbits) qstore_reg
  (
    .clk   (clk),
    .reset (reset),
    .en    (write_en),
    .d     (recv_msg),
    .q     (qstore)
  );

  // Bypass muxing

  generate
  if ( |(p_type & `VC_QUEUE_BYPASS ) )

    vc_Mux2#(p_msg_nbits) bypass_mux
    (
      .in0 (qstore),
      .in1 (recv_msg),
      .sel (bypass_mux_sel),
      .out (send_msg)
    );

  else
    assign send_msg = qstore;
  endgenerate

endmodule

//------------------------------------------------------------------------
// Multi-Element Queue Control Logic
//------------------------------------------------------------------------
// This is the control logic for a multi-elment queue. It is designed to
// be attached to a Regfile storage element. Additionally, it includes
// the ability to statically enable pipeline and/or bypass behavior.
// Pipeline behavior is when the send_rdy signal is combinationally wired
// to the recv_rdy signal allowing elements to be dequeued and enqueued in
// the same cycle when the queue is full. Bypass behavior is when the
// recv_val signal is cominationally wired to the send_val signal allowing
// elements to bypass the storage element if the storage element is
// empty.

module vc_QueueCtrl
#(
  parameter p_type     = `VC_QUEUE_NORMAL,
  parameter p_num_msgs = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                    clk, reset,

  input  logic                    recv_val,        // Enqueue is valid
  output logic                    recv_rdy,        // Ready for producer to enqueue

  output logic                    send_val,        // Dequeue is called
  input  logic                    send_rdy,        // Consumer is ready to dequeue

  output logic                    write_en,       // Wen to wire to regfile
  output logic [c_addr_nbits-1:0] write_addr,     // Waddr to wire to regfile
  output logic [c_addr_nbits-1:0] read_addr,      // Raddr to wire to regfile
  output logic                    bypass_mux_sel, // Control mux for bypass queues
  output logic [c_addr_nbits:0]   num_free_entries // Num of free entries in queue
);

  // Enqueue and dequeue pointers

  logic [c_addr_nbits-1:0] enq_ptr;
  logic [c_addr_nbits-1:0] enq_ptr_next;

  vc_ResetReg#(c_addr_nbits) enq_ptr_reg
  (
    .clk     (clk),
    .reset   (reset),
    .d       (enq_ptr_next),
    .q       (enq_ptr)
  );

  logic [c_addr_nbits-1:0] deq_ptr;
  logic [c_addr_nbits-1:0] deq_ptr_next;

  vc_ResetReg#(c_addr_nbits) deq_ptr_reg
  (
    .clk   (clk),
    .reset (reset),
    .d     (deq_ptr_next),
    .q     (deq_ptr)
  );

  assign write_addr = enq_ptr;
  assign read_addr  = deq_ptr;

  // Extra state to tell difference between full and empty

  logic full;
  logic full_next;

  vc_ResetReg#(1) full_reg
  (
    .clk   (clk),
    .reset (reset),
    .d     (full_next),
    .q     (full)
  );

  // Determine if pipeline or bypass behavior is enabled

  localparam c_pipe_en   = |( p_type & `VC_QUEUE_PIPE   );
  localparam c_bypass_en = |( p_type & `VC_QUEUE_BYPASS );

  // We enq/deq only when they are both ready and valid

  logic  do_enq;
  assign do_enq = recv_rdy && recv_val;

  logic  do_deq;
  assign do_deq = send_rdy && send_val;

  // Determine if we have pipeline or bypass behaviour and
  // set the write enable accordingly.

  logic  empty;
  assign empty = ~full && (enq_ptr == deq_ptr);

  logic  do_pipe;
  assign do_pipe = c_pipe_en && full  && do_enq && do_deq;

  logic  do_bypass;
  assign do_bypass = c_bypass_en && empty && do_enq && do_deq;

  assign write_en = do_enq && ~do_bypass;

  // Regardless of the type of queue or whether or not we are actually
  // doing a bypass, if the queue is empty then we select the enq bits,
  // otherwise we select the output of the queue state elements.

  assign bypass_mux_sel = empty;

  // Ready signals are calculated from full register. If pipeline
  // behavior is enabled, then the recv_rdy signal is also calculated
  // combinationally from the send_rdy signal. If bypass behavior is
  // enabled then the send_val signal is also calculated combinationally
  // from the recv_val signal.

  assign recv_rdy = ~full  || ( c_pipe_en   && full  && send_rdy );
  assign send_val = ~empty || ( c_bypass_en && empty && recv_val );

  // Control logic for the enq/deq pointers and full register

  logic [c_addr_nbits-1:0] deq_ptr_plus1;
  assign deq_ptr_plus1 = deq_ptr + 1'b1;

  /* verilator lint_off WIDTH */

  logic [c_addr_nbits-1:0] deq_ptr_inc;
  assign deq_ptr_inc = (deq_ptr_plus1 == p_num_msgs) ? {c_addr_nbits{1'b0}} : deq_ptr_plus1;

  logic [c_addr_nbits-1:0] enq_ptr_plus1;
  assign enq_ptr_plus1 = enq_ptr + 1'b1;

  logic [c_addr_nbits-1:0] enq_ptr_inc;
  assign enq_ptr_inc = (enq_ptr_plus1 == p_num_msgs) ? {c_addr_nbits{1'b0}} : enq_ptr_plus1;

  /* verilator lint_on WIDTH */

  assign deq_ptr_next
    = ( do_deq && ~do_bypass ) ? ( deq_ptr_inc ) : deq_ptr;

  assign enq_ptr_next
    = ( do_enq && ~do_bypass ) ? ( enq_ptr_inc ) : enq_ptr;

  assign full_next
    = ( do_enq && ~do_deq && ( enq_ptr_inc == deq_ptr ) ) ? 1'b1
    : ( do_deq && full && ~do_pipe )                      ? 1'b0
    :                                                       full;

  // Number of free entries

  assign num_free_entries
    = full                ? {(c_addr_nbits+1){1'b0}}
    : empty               ? p_num_msgs[c_addr_nbits:0]
    : (enq_ptr > deq_ptr) ? p_num_msgs[c_addr_nbits:0] - (enq_ptr - deq_ptr)
    : (deq_ptr > enq_ptr) ? deq_ptr - enq_ptr
    :                       {(c_addr_nbits+1){1'bx}};

endmodule

//------------------------------------------------------------------------
// Multi-Element Queue Datapath
//------------------------------------------------------------------------
// This is the datpath for multi-element queues. It includes a register
// and a bypass mux if needed.

module vc_QueueDpath
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 4,
  parameter p_num_msgs  = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                    clk,
  input  logic                    reset,
  input  logic                    write_en,
  input  logic                    bypass_mux_sel,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [c_addr_nbits-1:0] read_addr,
  input  logic [p_msg_nbits-1:0]  recv_msg,
  output logic [p_msg_nbits-1:0]  send_msg
);

  // Queue storage

  logic [p_msg_nbits-1:0] read_data;

  vc_Regfile_1r1w#(p_msg_nbits,p_num_msgs) qstore
  (
    .clk        (clk),
    .reset      (reset),
    .read_addr  (read_addr),
    .read_data  (read_data),
    .write_en   (write_en),
    .write_addr (write_addr),
    .write_data (recv_msg)
  );

  // Bypass muxing

  generate
  if ( |(p_type & `VC_QUEUE_BYPASS ) )

    vc_Mux2#(p_msg_nbits) bypass_mux
    (
      .in0 (read_data),
      .in1 (recv_msg),
      .sel (bypass_mux_sel),
      .out (send_msg)
    );

  else
    assign send_msg = read_data;
  endgenerate

endmodule

//------------------------------------------------------------------------
// Queue
//------------------------------------------------------------------------

module vc_Queue
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 1,
  parameter p_num_msgs  = 2,

  // parameters not meant to be set outside this module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                   clk,
  input  logic                   reset,

  input  logic                   recv_val,
  output logic                   recv_rdy,
  input  logic [p_msg_nbits-1:0] recv_msg,

  output logic                   send_val,
  input  logic                   send_rdy,
  output logic [p_msg_nbits-1:0] send_msg,

  output logic [c_addr_nbits:0]  num_free_entries
);


  generate
  if ( p_num_msgs == 1 )
  begin

    logic write_en;
    logic bypass_mux_sel;

    vc_QueueCtrl1#(p_type) ctrl
    (
      .clk              (clk),
      .reset            (reset),
      .recv_val         (recv_val),
      .recv_rdy         (recv_rdy),
      .send_val         (send_val),
      .send_rdy         (send_rdy),
      .write_en         (write_en),
      .bypass_mux_sel   (bypass_mux_sel),
      .num_free_entries (num_free_entries)
    );

    vc_QueueDpath1#(p_type,p_msg_nbits) dpath
    (
      .clk            (clk),
      .reset          (reset),
      .write_en       (write_en),
      .bypass_mux_sel (bypass_mux_sel),
      .recv_msg       (recv_msg),
      .send_msg       (send_msg)
    );

  end
  else
  begin

    logic                    write_en;
    logic                    bypass_mux_sel;
    logic [c_addr_nbits-1:0] write_addr;
    logic [c_addr_nbits-1:0] read_addr;

    vc_QueueCtrl#(p_type,p_num_msgs) ctrl
    (
      .clk              (clk),
      .reset            (reset),
      .recv_val         (recv_val),
      .recv_rdy         (recv_rdy),
      .send_val         (send_val),
      .send_rdy         (send_rdy),
      .write_en         (write_en),
      .write_addr       (write_addr),
      .read_addr        (read_addr),
      .bypass_mux_sel   (bypass_mux_sel),
      .num_free_entries (num_free_entries)
    );

    vc_QueueDpath#(p_type,p_msg_nbits,p_num_msgs) dpath
    (
      .clk              (clk),
      .reset            (reset),
      .write_en         (write_en),
      .bypass_mux_sel   (bypass_mux_sel),
      .write_addr       (write_addr),
      .read_addr        (read_addr),
      .recv_msg         (recv_msg),
      .send_msg         (send_msg)
    );

  end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( enq_en  );
      `VC_ASSERT_NOT_X( enq_rdy );
      `VC_ASSERT_NOT_X( deq_en  );
      `VC_ASSERT_NOT_X( deq_rdy );
    end
  end
  */

  // Line Tracing

  //  logic [`VC_TRACE_NBITS_TO_NCHARS(p_msg_nbits)*8-1:0] str;
  //
  //  `VC_TRACE_BEGIN
  //  begin
  //
  //    $sformat( str, "%x", enq_msg );
  //    vc_trace.append_en_rdy_str( trace_str, enq_en, enq_rdy, str );
  //
  //    vc_trace.append_str( trace_str, "(" );
  //    $sformat( str, "%x", p_num_msgs-num_free_entries );
  //    vc_trace.append_str( trace_str, str );
  //    vc_trace.append_str( trace_str, ")" );
  //
  //    $sformat( str, "%x", deq_msg );
  //    vc_trace.append_en_rdy_str( trace_str, deq_en, deq_rdy, str );

  // end
  // endtask

endmodule

`endif /* VC_QUEUES_V */
`line 13 "../../../spi_minion/sim/SPI_minion/components/SPIMinionAdapterVRTL.v" 0

module SPI_minion_components_SPIMinionAdapterVRTL
#(
  parameter nbits = 8,
  parameter num_entries = 1
)
(
  input  logic                    clk,
  input  logic                    reset,
  input  logic                    pull_en,
  output logic                    pull_msg_val,
  output logic                    pull_msg_spc,
  output logic [nbits-3:0]        pull_msg_data,
  input  logic                    push_en,
  input  logic                    push_msg_val_wrt,
  input  logic                    push_msg_val_rd,
  input  logic [nbits-3:0]        push_msg_data,
  input  logic [nbits-3:0]        recv_msg,
  output logic                    recv_rdy,
  input  logic                    recv_val,
  output logic [nbits-3:0]        send_msg,
  input  logic                    send_rdy,
  output logic                    send_val,
  output logic                    parity  
);

  logic open_entries;

  logic [nbits-3:0]             cm_q_send_msg;
  logic                         cm_q_send_rdy;
  logic                         cm_q_send_val;

  vc_Queue #(4'b0, nbits-2, num_entries) cm_q
  (
    .clk( clk ),
    .num_free_entries( ),
    .reset( reset ),
    .recv_msg( recv_msg ),
    .recv_rdy( recv_rdy ),
    .recv_val( recv_val ),
    .send_msg( cm_q_send_msg ),
    .send_rdy( cm_q_send_rdy ),
    .send_val( cm_q_send_val )
  );

  logic [$clog2(num_entries):0] mc_q_num_free;
  logic                         mc_q_recv_rdy;
  logic                         mc_q_recv_val;

  vc_Queue #(4'b0, nbits-2, num_entries) mc_q
  (
    .clk( clk ),
    .num_free_entries( mc_q_num_free ),
    .reset( reset ),
    .recv_msg( push_msg_data ),
    .recv_rdy( mc_q_recv_rdy ),
    .recv_val( mc_q_recv_val ),
    .send_msg( send_msg ),
    .send_rdy( send_rdy ),
    .send_val( send_val )
  );

  assign parity = (^send_msg) & send_val;
  
  always_comb begin : comb_block
    open_entries  = mc_q_num_free > 1;
    mc_q_recv_val = push_msg_val_wrt & push_en;
    pull_msg_spc  = mc_q_recv_rdy & ( ( ~mc_q_recv_val ) | open_entries );
    cm_q_send_rdy = push_msg_val_rd & pull_en;
    pull_msg_val  = cm_q_send_rdy & cm_q_send_val;
    pull_msg_data = cm_q_send_msg & { (nbits-2){pull_msg_val} };
  end

endmodule

`endif /* SPI_V3_COMPONENTS_MINION_ADAPTER_V */
`line 5 "../../../tape_in_sim/sim/minion_FFT/FFTSPIMinionVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFTVRTL.v" 0

`ifndef FFT_VRTL
`define FFT_VRTL

`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/TwiddleGeneratorVRTL.v" 0
`ifndef TWIDDLE_GENERATOR
`define TWIDDLE_GENERATOR
module TwiddleGeneratorVRTL 
   #(
        BIT_WIDTH     = 4,
        DECIMAL_PT    = 2,
        SIZE_FFT      = 8,
        STAGE_FFT     = 0 
    )
    (
        input logic  [BIT_WIDTH - 1:0] sine_wave_in     [0:SIZE_FFT - 1], //sine_wave_in = sin(2*pi m / N)
        
        output logic [BIT_WIDTH - 1:0] twiddle_real     [SIZE_FFT/2 - 1:0],
        output logic [BIT_WIDTH - 1:0] twiddle_imaginary[SIZE_FFT/2 - 1:0]
    );

    int trace;
    assign trace =  1'd1 << DECIMAL_PT;
    int trace2;
    assign trace2 = ( 1 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    int trace3;
    assign trace3 = ( 2 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    int trace4;
    assign trace4 = ( 3 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    generate
        genvar m;
        //if(SIZE_FFT > 2) begin 
            for(m = 0; m < 2 ** STAGE_FFT; m = m + 1) begin
                genvar i;
                for(i = 0; i < SIZE_FFT; i = i + 2 ** (STAGE_FFT + 1) ) begin
                    if(m == 0) begin
                        assign twiddle_real     [i/2 + m] = 1'b1 << DECIMAL_PT;
                        assign twiddle_imaginary[i/2 + m] = 0;
                    end else begin
						assign twiddle_real     [i/2 + m] =  sine_wave_in[(  m * ( SIZE_FFT / ( 2 * (2**STAGE_FFT) ) ) + SIZE_FFT/4) % SIZE_FFT   ];
                        assign twiddle_imaginary[i/2 + m] =  -sine_wave_in[(  ( m * ( SIZE_FFT / ( 2 * (2**STAGE_FFT) ) ) ) % SIZE_FFT )              ];
                    end
                end
            end
        //end else begin
        //    genvar i;
        //    for(i = 0; i < (SIZE_FFT/2) - 1; i++) begin 
        //        assign twiddle_real[i] = 1 << DECIMAL_PT;
        //        assign twiddle_imaginary[i] = 0;
        //    end
        //end
    endgenerate

endmodule

`endif

`line 6 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_512VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 512
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_512VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:512 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 804;
   assign sine_wave_out[2] = 1608;
   assign sine_wave_out[3] = 2412;
   assign sine_wave_out[4] = 3215;
   assign sine_wave_out[5] = 4018;
   assign sine_wave_out[6] = 4821;
   assign sine_wave_out[7] = 5622;
   assign sine_wave_out[8] = 6423;
   assign sine_wave_out[9] = 7223;
   assign sine_wave_out[10] = 8022;
   assign sine_wave_out[11] = 8819;
   assign sine_wave_out[12] = 9616;
   assign sine_wave_out[13] = 10410;
   assign sine_wave_out[14] = 11204;
   assign sine_wave_out[15] = 11995;
   assign sine_wave_out[16] = 12785;
   assign sine_wave_out[17] = 13573;
   assign sine_wave_out[18] = 14359;
   assign sine_wave_out[19] = 15142;
   assign sine_wave_out[20] = 15923;
   assign sine_wave_out[21] = 16702;
   assign sine_wave_out[22] = 17479;
   assign sine_wave_out[23] = 18253;
   assign sine_wave_out[24] = 19024;
   assign sine_wave_out[25] = 19792;
   assign sine_wave_out[26] = 20557;
   assign sine_wave_out[27] = 21319;
   assign sine_wave_out[28] = 22078;
   assign sine_wave_out[29] = 22833;
   assign sine_wave_out[30] = 23586;
   assign sine_wave_out[31] = 24334;
   assign sine_wave_out[32] = 25079;
   assign sine_wave_out[33] = 25820;
   assign sine_wave_out[34] = 26557;
   assign sine_wave_out[35] = 27291;
   assign sine_wave_out[36] = 28020;
   assign sine_wave_out[37] = 28745;
   assign sine_wave_out[38] = 29465;
   assign sine_wave_out[39] = 30181;
   assign sine_wave_out[40] = 30893;
   assign sine_wave_out[41] = 31600;
   assign sine_wave_out[42] = 32302;
   assign sine_wave_out[43] = 32999;
   assign sine_wave_out[44] = 33692;
   assign sine_wave_out[45] = 34379;
   assign sine_wave_out[46] = 35061;
   assign sine_wave_out[47] = 35738;
   assign sine_wave_out[48] = 36409;
   assign sine_wave_out[49] = 37075;
   assign sine_wave_out[50] = 37736;
   assign sine_wave_out[51] = 38390;
   assign sine_wave_out[52] = 39039;
   assign sine_wave_out[53] = 39682;
   assign sine_wave_out[54] = 40319;
   assign sine_wave_out[55] = 40950;
   assign sine_wave_out[56] = 41575;
   assign sine_wave_out[57] = 42194;
   assign sine_wave_out[58] = 42806;
   assign sine_wave_out[59] = 43412;
   assign sine_wave_out[60] = 44011;
   assign sine_wave_out[61] = 44603;
   assign sine_wave_out[62] = 45189;
   assign sine_wave_out[63] = 45768;
   assign sine_wave_out[64] = 46340;
   assign sine_wave_out[65] = 46906;
   assign sine_wave_out[66] = 47464;
   assign sine_wave_out[67] = 48015;
   assign sine_wave_out[68] = 48558;
   assign sine_wave_out[69] = 49095;
   assign sine_wave_out[70] = 49624;
   assign sine_wave_out[71] = 50146;
   assign sine_wave_out[72] = 50660;
   assign sine_wave_out[73] = 51166;
   assign sine_wave_out[74] = 51665;
   assign sine_wave_out[75] = 52155;
   assign sine_wave_out[76] = 52639;
   assign sine_wave_out[77] = 53114;
   assign sine_wave_out[78] = 53581;
   assign sine_wave_out[79] = 54040;
   assign sine_wave_out[80] = 54491;
   assign sine_wave_out[81] = 54933;
   assign sine_wave_out[82] = 55368;
   assign sine_wave_out[83] = 55794;
   assign sine_wave_out[84] = 56212;
   assign sine_wave_out[85] = 56621;
   assign sine_wave_out[86] = 57022;
   assign sine_wave_out[87] = 57414;
   assign sine_wave_out[88] = 57797;
   assign sine_wave_out[89] = 58172;
   assign sine_wave_out[90] = 58538;
   assign sine_wave_out[91] = 58895;
   assign sine_wave_out[92] = 59243;
   assign sine_wave_out[93] = 59583;
   assign sine_wave_out[94] = 59913;
   assign sine_wave_out[95] = 60235;
   assign sine_wave_out[96] = 60547;
   assign sine_wave_out[97] = 60850;
   assign sine_wave_out[98] = 61144;
   assign sine_wave_out[99] = 61429;
   assign sine_wave_out[100] = 61705;
   assign sine_wave_out[101] = 61971;
   assign sine_wave_out[102] = 62228;
   assign sine_wave_out[103] = 62475;
   assign sine_wave_out[104] = 62714;
   assign sine_wave_out[105] = 62942;
   assign sine_wave_out[106] = 63162;
   assign sine_wave_out[107] = 63371;
   assign sine_wave_out[108] = 63571;
   assign sine_wave_out[109] = 63762;
   assign sine_wave_out[110] = 63943;
   assign sine_wave_out[111] = 64115;
   assign sine_wave_out[112] = 64276;
   assign sine_wave_out[113] = 64428;
   assign sine_wave_out[114] = 64571;
   assign sine_wave_out[115] = 64703;
   assign sine_wave_out[116] = 64826;
   assign sine_wave_out[117] = 64939;
   assign sine_wave_out[118] = 65043;
   assign sine_wave_out[119] = 65136;
   assign sine_wave_out[120] = 65220;
   assign sine_wave_out[121] = 65294;
   assign sine_wave_out[122] = 65358;
   assign sine_wave_out[123] = 65412;
   assign sine_wave_out[124] = 65457;
   assign sine_wave_out[125] = 65491;
   assign sine_wave_out[126] = 65516;
   assign sine_wave_out[127] = 65531;
   assign sine_wave_out[128] = 65536;
   assign sine_wave_out[129] = 65531;
   assign sine_wave_out[130] = 65516;
   assign sine_wave_out[131] = 65491;
   assign sine_wave_out[132] = 65457;
   assign sine_wave_out[133] = 65412;
   assign sine_wave_out[134] = 65358;
   assign sine_wave_out[135] = 65294;
   assign sine_wave_out[136] = 65220;
   assign sine_wave_out[137] = 65136;
   assign sine_wave_out[138] = 65043;
   assign sine_wave_out[139] = 64939;
   assign sine_wave_out[140] = 64826;
   assign sine_wave_out[141] = 64703;
   assign sine_wave_out[142] = 64571;
   assign sine_wave_out[143] = 64428;
   assign sine_wave_out[144] = 64276;
   assign sine_wave_out[145] = 64115;
   assign sine_wave_out[146] = 63943;
   assign sine_wave_out[147] = 63762;
   assign sine_wave_out[148] = 63571;
   assign sine_wave_out[149] = 63371;
   assign sine_wave_out[150] = 63162;
   assign sine_wave_out[151] = 62942;
   assign sine_wave_out[152] = 62714;
   assign sine_wave_out[153] = 62475;
   assign sine_wave_out[154] = 62228;
   assign sine_wave_out[155] = 61971;
   assign sine_wave_out[156] = 61705;
   assign sine_wave_out[157] = 61429;
   assign sine_wave_out[158] = 61144;
   assign sine_wave_out[159] = 60850;
   assign sine_wave_out[160] = 60547;
   assign sine_wave_out[161] = 60235;
   assign sine_wave_out[162] = 59913;
   assign sine_wave_out[163] = 59583;
   assign sine_wave_out[164] = 59243;
   assign sine_wave_out[165] = 58895;
   assign sine_wave_out[166] = 58538;
   assign sine_wave_out[167] = 58172;
   assign sine_wave_out[168] = 57797;
   assign sine_wave_out[169] = 57414;
   assign sine_wave_out[170] = 57022;
   assign sine_wave_out[171] = 56621;
   assign sine_wave_out[172] = 56212;
   assign sine_wave_out[173] = 55794;
   assign sine_wave_out[174] = 55368;
   assign sine_wave_out[175] = 54933;
   assign sine_wave_out[176] = 54491;
   assign sine_wave_out[177] = 54040;
   assign sine_wave_out[178] = 53581;
   assign sine_wave_out[179] = 53114;
   assign sine_wave_out[180] = 52639;
   assign sine_wave_out[181] = 52155;
   assign sine_wave_out[182] = 51665;
   assign sine_wave_out[183] = 51166;
   assign sine_wave_out[184] = 50660;
   assign sine_wave_out[185] = 50146;
   assign sine_wave_out[186] = 49624;
   assign sine_wave_out[187] = 49095;
   assign sine_wave_out[188] = 48558;
   assign sine_wave_out[189] = 48015;
   assign sine_wave_out[190] = 47464;
   assign sine_wave_out[191] = 46906;
   assign sine_wave_out[192] = 46340;
   assign sine_wave_out[193] = 45768;
   assign sine_wave_out[194] = 45189;
   assign sine_wave_out[195] = 44603;
   assign sine_wave_out[196] = 44011;
   assign sine_wave_out[197] = 43412;
   assign sine_wave_out[198] = 42806;
   assign sine_wave_out[199] = 42194;
   assign sine_wave_out[200] = 41575;
   assign sine_wave_out[201] = 40950;
   assign sine_wave_out[202] = 40319;
   assign sine_wave_out[203] = 39682;
   assign sine_wave_out[204] = 39039;
   assign sine_wave_out[205] = 38390;
   assign sine_wave_out[206] = 37736;
   assign sine_wave_out[207] = 37075;
   assign sine_wave_out[208] = 36409;
   assign sine_wave_out[209] = 35738;
   assign sine_wave_out[210] = 35061;
   assign sine_wave_out[211] = 34379;
   assign sine_wave_out[212] = 33692;
   assign sine_wave_out[213] = 32999;
   assign sine_wave_out[214] = 32302;
   assign sine_wave_out[215] = 31600;
   assign sine_wave_out[216] = 30893;
   assign sine_wave_out[217] = 30181;
   assign sine_wave_out[218] = 29465;
   assign sine_wave_out[219] = 28745;
   assign sine_wave_out[220] = 28020;
   assign sine_wave_out[221] = 27291;
   assign sine_wave_out[222] = 26557;
   assign sine_wave_out[223] = 25820;
   assign sine_wave_out[224] = 25079;
   assign sine_wave_out[225] = 24334;
   assign sine_wave_out[226] = 23586;
   assign sine_wave_out[227] = 22833;
   assign sine_wave_out[228] = 22078;
   assign sine_wave_out[229] = 21319;
   assign sine_wave_out[230] = 20557;
   assign sine_wave_out[231] = 19792;
   assign sine_wave_out[232] = 19024;
   assign sine_wave_out[233] = 18253;
   assign sine_wave_out[234] = 17479;
   assign sine_wave_out[235] = 16702;
   assign sine_wave_out[236] = 15923;
   assign sine_wave_out[237] = 15142;
   assign sine_wave_out[238] = 14359;
   assign sine_wave_out[239] = 13573;
   assign sine_wave_out[240] = 12785;
   assign sine_wave_out[241] = 11995;
   assign sine_wave_out[242] = 11204;
   assign sine_wave_out[243] = 10410;
   assign sine_wave_out[244] = 9616;
   assign sine_wave_out[245] = 8819;
   assign sine_wave_out[246] = 8022;
   assign sine_wave_out[247] = 7223;
   assign sine_wave_out[248] = 6423;
   assign sine_wave_out[249] = 5622;
   assign sine_wave_out[250] = 4821;
   assign sine_wave_out[251] = 4018;
   assign sine_wave_out[252] = 3215;
   assign sine_wave_out[253] = 2412;
   assign sine_wave_out[254] = 1608;
   assign sine_wave_out[255] = 804;
   assign sine_wave_out[256] = 0;
   assign sine_wave_out[257] = -804;
   assign sine_wave_out[258] = -1608;
   assign sine_wave_out[259] = -2412;
   assign sine_wave_out[260] = -3215;
   assign sine_wave_out[261] = -4018;
   assign sine_wave_out[262] = -4821;
   assign sine_wave_out[263] = -5622;
   assign sine_wave_out[264] = -6423;
   assign sine_wave_out[265] = -7223;
   assign sine_wave_out[266] = -8022;
   assign sine_wave_out[267] = -8819;
   assign sine_wave_out[268] = -9616;
   assign sine_wave_out[269] = -10410;
   assign sine_wave_out[270] = -11204;
   assign sine_wave_out[271] = -11995;
   assign sine_wave_out[272] = -12785;
   assign sine_wave_out[273] = -13573;
   assign sine_wave_out[274] = -14359;
   assign sine_wave_out[275] = -15142;
   assign sine_wave_out[276] = -15923;
   assign sine_wave_out[277] = -16702;
   assign sine_wave_out[278] = -17479;
   assign sine_wave_out[279] = -18253;
   assign sine_wave_out[280] = -19024;
   assign sine_wave_out[281] = -19792;
   assign sine_wave_out[282] = -20557;
   assign sine_wave_out[283] = -21319;
   assign sine_wave_out[284] = -22078;
   assign sine_wave_out[285] = -22833;
   assign sine_wave_out[286] = -23586;
   assign sine_wave_out[287] = -24334;
   assign sine_wave_out[288] = -25079;
   assign sine_wave_out[289] = -25820;
   assign sine_wave_out[290] = -26557;
   assign sine_wave_out[291] = -27291;
   assign sine_wave_out[292] = -28020;
   assign sine_wave_out[293] = -28745;
   assign sine_wave_out[294] = -29465;
   assign sine_wave_out[295] = -30181;
   assign sine_wave_out[296] = -30893;
   assign sine_wave_out[297] = -31600;
   assign sine_wave_out[298] = -32302;
   assign sine_wave_out[299] = -32999;
   assign sine_wave_out[300] = -33692;
   assign sine_wave_out[301] = -34379;
   assign sine_wave_out[302] = -35061;
   assign sine_wave_out[303] = -35738;
   assign sine_wave_out[304] = -36409;
   assign sine_wave_out[305] = -37075;
   assign sine_wave_out[306] = -37736;
   assign sine_wave_out[307] = -38390;
   assign sine_wave_out[308] = -39039;
   assign sine_wave_out[309] = -39682;
   assign sine_wave_out[310] = -40319;
   assign sine_wave_out[311] = -40950;
   assign sine_wave_out[312] = -41575;
   assign sine_wave_out[313] = -42194;
   assign sine_wave_out[314] = -42806;
   assign sine_wave_out[315] = -43412;
   assign sine_wave_out[316] = -44011;
   assign sine_wave_out[317] = -44603;
   assign sine_wave_out[318] = -45189;
   assign sine_wave_out[319] = -45768;
   assign sine_wave_out[320] = -46340;
   assign sine_wave_out[321] = -46906;
   assign sine_wave_out[322] = -47464;
   assign sine_wave_out[323] = -48015;
   assign sine_wave_out[324] = -48558;
   assign sine_wave_out[325] = -49095;
   assign sine_wave_out[326] = -49624;
   assign sine_wave_out[327] = -50146;
   assign sine_wave_out[328] = -50660;
   assign sine_wave_out[329] = -51166;
   assign sine_wave_out[330] = -51665;
   assign sine_wave_out[331] = -52155;
   assign sine_wave_out[332] = -52639;
   assign sine_wave_out[333] = -53114;
   assign sine_wave_out[334] = -53581;
   assign sine_wave_out[335] = -54040;
   assign sine_wave_out[336] = -54491;
   assign sine_wave_out[337] = -54933;
   assign sine_wave_out[338] = -55368;
   assign sine_wave_out[339] = -55794;
   assign sine_wave_out[340] = -56212;
   assign sine_wave_out[341] = -56621;
   assign sine_wave_out[342] = -57022;
   assign sine_wave_out[343] = -57414;
   assign sine_wave_out[344] = -57797;
   assign sine_wave_out[345] = -58172;
   assign sine_wave_out[346] = -58538;
   assign sine_wave_out[347] = -58895;
   assign sine_wave_out[348] = -59243;
   assign sine_wave_out[349] = -59583;
   assign sine_wave_out[350] = -59913;
   assign sine_wave_out[351] = -60235;
   assign sine_wave_out[352] = -60547;
   assign sine_wave_out[353] = -60850;
   assign sine_wave_out[354] = -61144;
   assign sine_wave_out[355] = -61429;
   assign sine_wave_out[356] = -61705;
   assign sine_wave_out[357] = -61971;
   assign sine_wave_out[358] = -62228;
   assign sine_wave_out[359] = -62475;
   assign sine_wave_out[360] = -62714;
   assign sine_wave_out[361] = -62942;
   assign sine_wave_out[362] = -63162;
   assign sine_wave_out[363] = -63371;
   assign sine_wave_out[364] = -63571;
   assign sine_wave_out[365] = -63762;
   assign sine_wave_out[366] = -63943;
   assign sine_wave_out[367] = -64115;
   assign sine_wave_out[368] = -64276;
   assign sine_wave_out[369] = -64428;
   assign sine_wave_out[370] = -64571;
   assign sine_wave_out[371] = -64703;
   assign sine_wave_out[372] = -64826;
   assign sine_wave_out[373] = -64939;
   assign sine_wave_out[374] = -65043;
   assign sine_wave_out[375] = -65136;
   assign sine_wave_out[376] = -65220;
   assign sine_wave_out[377] = -65294;
   assign sine_wave_out[378] = -65358;
   assign sine_wave_out[379] = -65412;
   assign sine_wave_out[380] = -65457;
   assign sine_wave_out[381] = -65491;
   assign sine_wave_out[382] = -65516;
   assign sine_wave_out[383] = -65531;
   assign sine_wave_out[384] = -65536;
   assign sine_wave_out[385] = -65531;
   assign sine_wave_out[386] = -65516;
   assign sine_wave_out[387] = -65491;
   assign sine_wave_out[388] = -65457;
   assign sine_wave_out[389] = -65412;
   assign sine_wave_out[390] = -65358;
   assign sine_wave_out[391] = -65294;
   assign sine_wave_out[392] = -65220;
   assign sine_wave_out[393] = -65136;
   assign sine_wave_out[394] = -65043;
   assign sine_wave_out[395] = -64939;
   assign sine_wave_out[396] = -64826;
   assign sine_wave_out[397] = -64703;
   assign sine_wave_out[398] = -64571;
   assign sine_wave_out[399] = -64428;
   assign sine_wave_out[400] = -64276;
   assign sine_wave_out[401] = -64115;
   assign sine_wave_out[402] = -63943;
   assign sine_wave_out[403] = -63762;
   assign sine_wave_out[404] = -63571;
   assign sine_wave_out[405] = -63371;
   assign sine_wave_out[406] = -63162;
   assign sine_wave_out[407] = -62942;
   assign sine_wave_out[408] = -62714;
   assign sine_wave_out[409] = -62475;
   assign sine_wave_out[410] = -62228;
   assign sine_wave_out[411] = -61971;
   assign sine_wave_out[412] = -61705;
   assign sine_wave_out[413] = -61429;
   assign sine_wave_out[414] = -61144;
   assign sine_wave_out[415] = -60850;
   assign sine_wave_out[416] = -60547;
   assign sine_wave_out[417] = -60235;
   assign sine_wave_out[418] = -59913;
   assign sine_wave_out[419] = -59583;
   assign sine_wave_out[420] = -59243;
   assign sine_wave_out[421] = -58895;
   assign sine_wave_out[422] = -58538;
   assign sine_wave_out[423] = -58172;
   assign sine_wave_out[424] = -57797;
   assign sine_wave_out[425] = -57414;
   assign sine_wave_out[426] = -57022;
   assign sine_wave_out[427] = -56621;
   assign sine_wave_out[428] = -56212;
   assign sine_wave_out[429] = -55794;
   assign sine_wave_out[430] = -55368;
   assign sine_wave_out[431] = -54933;
   assign sine_wave_out[432] = -54491;
   assign sine_wave_out[433] = -54040;
   assign sine_wave_out[434] = -53581;
   assign sine_wave_out[435] = -53114;
   assign sine_wave_out[436] = -52639;
   assign sine_wave_out[437] = -52155;
   assign sine_wave_out[438] = -51665;
   assign sine_wave_out[439] = -51166;
   assign sine_wave_out[440] = -50660;
   assign sine_wave_out[441] = -50146;
   assign sine_wave_out[442] = -49624;
   assign sine_wave_out[443] = -49095;
   assign sine_wave_out[444] = -48558;
   assign sine_wave_out[445] = -48015;
   assign sine_wave_out[446] = -47464;
   assign sine_wave_out[447] = -46906;
   assign sine_wave_out[448] = -46340;
   assign sine_wave_out[449] = -45768;
   assign sine_wave_out[450] = -45189;
   assign sine_wave_out[451] = -44603;
   assign sine_wave_out[452] = -44011;
   assign sine_wave_out[453] = -43412;
   assign sine_wave_out[454] = -42806;
   assign sine_wave_out[455] = -42194;
   assign sine_wave_out[456] = -41575;
   assign sine_wave_out[457] = -40950;
   assign sine_wave_out[458] = -40319;
   assign sine_wave_out[459] = -39682;
   assign sine_wave_out[460] = -39039;
   assign sine_wave_out[461] = -38390;
   assign sine_wave_out[462] = -37736;
   assign sine_wave_out[463] = -37075;
   assign sine_wave_out[464] = -36409;
   assign sine_wave_out[465] = -35738;
   assign sine_wave_out[466] = -35061;
   assign sine_wave_out[467] = -34379;
   assign sine_wave_out[468] = -33692;
   assign sine_wave_out[469] = -32999;
   assign sine_wave_out[470] = -32302;
   assign sine_wave_out[471] = -31600;
   assign sine_wave_out[472] = -30893;
   assign sine_wave_out[473] = -30181;
   assign sine_wave_out[474] = -29465;
   assign sine_wave_out[475] = -28745;
   assign sine_wave_out[476] = -28020;
   assign sine_wave_out[477] = -27291;
   assign sine_wave_out[478] = -26557;
   assign sine_wave_out[479] = -25820;
   assign sine_wave_out[480] = -25079;
   assign sine_wave_out[481] = -24334;
   assign sine_wave_out[482] = -23586;
   assign sine_wave_out[483] = -22833;
   assign sine_wave_out[484] = -22078;
   assign sine_wave_out[485] = -21319;
   assign sine_wave_out[486] = -20557;
   assign sine_wave_out[487] = -19792;
   assign sine_wave_out[488] = -19024;
   assign sine_wave_out[489] = -18253;
   assign sine_wave_out[490] = -17479;
   assign sine_wave_out[491] = -16702;
   assign sine_wave_out[492] = -15923;
   assign sine_wave_out[493] = -15142;
   assign sine_wave_out[494] = -14359;
   assign sine_wave_out[495] = -13573;
   assign sine_wave_out[496] = -12785;
   assign sine_wave_out[497] = -11995;
   assign sine_wave_out[498] = -11204;
   assign sine_wave_out[499] = -10410;
   assign sine_wave_out[500] = -9616;
   assign sine_wave_out[501] = -8819;
   assign sine_wave_out[502] = -8022;
   assign sine_wave_out[503] = -7223;
   assign sine_wave_out[504] = -6423;
   assign sine_wave_out[505] = -5622;
   assign sine_wave_out[506] = -4821;
   assign sine_wave_out[507] = -4018;
   assign sine_wave_out[508] = -3215;
   assign sine_wave_out[509] = -2412;
   assign sine_wave_out[510] = -1608;
   assign sine_wave_out[511] = -804;
endmodule
`line 7 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_256VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 256
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_256VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:256 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 1608;
   assign sine_wave_out[2] = 3215;
   assign sine_wave_out[3] = 4821;
   assign sine_wave_out[4] = 6423;
   assign sine_wave_out[5] = 8022;
   assign sine_wave_out[6] = 9616;
   assign sine_wave_out[7] = 11204;
   assign sine_wave_out[8] = 12785;
   assign sine_wave_out[9] = 14359;
   assign sine_wave_out[10] = 15923;
   assign sine_wave_out[11] = 17479;
   assign sine_wave_out[12] = 19024;
   assign sine_wave_out[13] = 20557;
   assign sine_wave_out[14] = 22078;
   assign sine_wave_out[15] = 23586;
   assign sine_wave_out[16] = 25079;
   assign sine_wave_out[17] = 26557;
   assign sine_wave_out[18] = 28020;
   assign sine_wave_out[19] = 29465;
   assign sine_wave_out[20] = 30893;
   assign sine_wave_out[21] = 32302;
   assign sine_wave_out[22] = 33692;
   assign sine_wave_out[23] = 35061;
   assign sine_wave_out[24] = 36409;
   assign sine_wave_out[25] = 37736;
   assign sine_wave_out[26] = 39039;
   assign sine_wave_out[27] = 40319;
   assign sine_wave_out[28] = 41575;
   assign sine_wave_out[29] = 42806;
   assign sine_wave_out[30] = 44011;
   assign sine_wave_out[31] = 45189;
   assign sine_wave_out[32] = 46340;
   assign sine_wave_out[33] = 47464;
   assign sine_wave_out[34] = 48558;
   assign sine_wave_out[35] = 49624;
   assign sine_wave_out[36] = 50660;
   assign sine_wave_out[37] = 51665;
   assign sine_wave_out[38] = 52639;
   assign sine_wave_out[39] = 53581;
   assign sine_wave_out[40] = 54491;
   assign sine_wave_out[41] = 55368;
   assign sine_wave_out[42] = 56212;
   assign sine_wave_out[43] = 57022;
   assign sine_wave_out[44] = 57797;
   assign sine_wave_out[45] = 58538;
   assign sine_wave_out[46] = 59243;
   assign sine_wave_out[47] = 59913;
   assign sine_wave_out[48] = 60547;
   assign sine_wave_out[49] = 61144;
   assign sine_wave_out[50] = 61705;
   assign sine_wave_out[51] = 62228;
   assign sine_wave_out[52] = 62714;
   assign sine_wave_out[53] = 63162;
   assign sine_wave_out[54] = 63571;
   assign sine_wave_out[55] = 63943;
   assign sine_wave_out[56] = 64276;
   assign sine_wave_out[57] = 64571;
   assign sine_wave_out[58] = 64826;
   assign sine_wave_out[59] = 65043;
   assign sine_wave_out[60] = 65220;
   assign sine_wave_out[61] = 65358;
   assign sine_wave_out[62] = 65457;
   assign sine_wave_out[63] = 65516;
   assign sine_wave_out[64] = 65536;
   assign sine_wave_out[65] = 65516;
   assign sine_wave_out[66] = 65457;
   assign sine_wave_out[67] = 65358;
   assign sine_wave_out[68] = 65220;
   assign sine_wave_out[69] = 65043;
   assign sine_wave_out[70] = 64826;
   assign sine_wave_out[71] = 64571;
   assign sine_wave_out[72] = 64276;
   assign sine_wave_out[73] = 63943;
   assign sine_wave_out[74] = 63571;
   assign sine_wave_out[75] = 63162;
   assign sine_wave_out[76] = 62714;
   assign sine_wave_out[77] = 62228;
   assign sine_wave_out[78] = 61705;
   assign sine_wave_out[79] = 61144;
   assign sine_wave_out[80] = 60547;
   assign sine_wave_out[81] = 59913;
   assign sine_wave_out[82] = 59243;
   assign sine_wave_out[83] = 58538;
   assign sine_wave_out[84] = 57797;
   assign sine_wave_out[85] = 57022;
   assign sine_wave_out[86] = 56212;
   assign sine_wave_out[87] = 55368;
   assign sine_wave_out[88] = 54491;
   assign sine_wave_out[89] = 53581;
   assign sine_wave_out[90] = 52639;
   assign sine_wave_out[91] = 51665;
   assign sine_wave_out[92] = 50660;
   assign sine_wave_out[93] = 49624;
   assign sine_wave_out[94] = 48558;
   assign sine_wave_out[95] = 47464;
   assign sine_wave_out[96] = 46340;
   assign sine_wave_out[97] = 45189;
   assign sine_wave_out[98] = 44011;
   assign sine_wave_out[99] = 42806;
   assign sine_wave_out[100] = 41575;
   assign sine_wave_out[101] = 40319;
   assign sine_wave_out[102] = 39039;
   assign sine_wave_out[103] = 37736;
   assign sine_wave_out[104] = 36409;
   assign sine_wave_out[105] = 35061;
   assign sine_wave_out[106] = 33692;
   assign sine_wave_out[107] = 32302;
   assign sine_wave_out[108] = 30893;
   assign sine_wave_out[109] = 29465;
   assign sine_wave_out[110] = 28020;
   assign sine_wave_out[111] = 26557;
   assign sine_wave_out[112] = 25079;
   assign sine_wave_out[113] = 23586;
   assign sine_wave_out[114] = 22078;
   assign sine_wave_out[115] = 20557;
   assign sine_wave_out[116] = 19024;
   assign sine_wave_out[117] = 17479;
   assign sine_wave_out[118] = 15923;
   assign sine_wave_out[119] = 14359;
   assign sine_wave_out[120] = 12785;
   assign sine_wave_out[121] = 11204;
   assign sine_wave_out[122] = 9616;
   assign sine_wave_out[123] = 8022;
   assign sine_wave_out[124] = 6423;
   assign sine_wave_out[125] = 4821;
   assign sine_wave_out[126] = 3215;
   assign sine_wave_out[127] = 1608;
   assign sine_wave_out[128] = 0;
   assign sine_wave_out[129] = -1608;
   assign sine_wave_out[130] = -3215;
   assign sine_wave_out[131] = -4821;
   assign sine_wave_out[132] = -6423;
   assign sine_wave_out[133] = -8022;
   assign sine_wave_out[134] = -9616;
   assign sine_wave_out[135] = -11204;
   assign sine_wave_out[136] = -12785;
   assign sine_wave_out[137] = -14359;
   assign sine_wave_out[138] = -15923;
   assign sine_wave_out[139] = -17479;
   assign sine_wave_out[140] = -19024;
   assign sine_wave_out[141] = -20557;
   assign sine_wave_out[142] = -22078;
   assign sine_wave_out[143] = -23586;
   assign sine_wave_out[144] = -25079;
   assign sine_wave_out[145] = -26557;
   assign sine_wave_out[146] = -28020;
   assign sine_wave_out[147] = -29465;
   assign sine_wave_out[148] = -30893;
   assign sine_wave_out[149] = -32302;
   assign sine_wave_out[150] = -33692;
   assign sine_wave_out[151] = -35061;
   assign sine_wave_out[152] = -36409;
   assign sine_wave_out[153] = -37736;
   assign sine_wave_out[154] = -39039;
   assign sine_wave_out[155] = -40319;
   assign sine_wave_out[156] = -41575;
   assign sine_wave_out[157] = -42806;
   assign sine_wave_out[158] = -44011;
   assign sine_wave_out[159] = -45189;
   assign sine_wave_out[160] = -46340;
   assign sine_wave_out[161] = -47464;
   assign sine_wave_out[162] = -48558;
   assign sine_wave_out[163] = -49624;
   assign sine_wave_out[164] = -50660;
   assign sine_wave_out[165] = -51665;
   assign sine_wave_out[166] = -52639;
   assign sine_wave_out[167] = -53581;
   assign sine_wave_out[168] = -54491;
   assign sine_wave_out[169] = -55368;
   assign sine_wave_out[170] = -56212;
   assign sine_wave_out[171] = -57022;
   assign sine_wave_out[172] = -57797;
   assign sine_wave_out[173] = -58538;
   assign sine_wave_out[174] = -59243;
   assign sine_wave_out[175] = -59913;
   assign sine_wave_out[176] = -60547;
   assign sine_wave_out[177] = -61144;
   assign sine_wave_out[178] = -61705;
   assign sine_wave_out[179] = -62228;
   assign sine_wave_out[180] = -62714;
   assign sine_wave_out[181] = -63162;
   assign sine_wave_out[182] = -63571;
   assign sine_wave_out[183] = -63943;
   assign sine_wave_out[184] = -64276;
   assign sine_wave_out[185] = -64571;
   assign sine_wave_out[186] = -64826;
   assign sine_wave_out[187] = -65043;
   assign sine_wave_out[188] = -65220;
   assign sine_wave_out[189] = -65358;
   assign sine_wave_out[190] = -65457;
   assign sine_wave_out[191] = -65516;
   assign sine_wave_out[192] = -65536;
   assign sine_wave_out[193] = -65516;
   assign sine_wave_out[194] = -65457;
   assign sine_wave_out[195] = -65358;
   assign sine_wave_out[196] = -65220;
   assign sine_wave_out[197] = -65043;
   assign sine_wave_out[198] = -64826;
   assign sine_wave_out[199] = -64571;
   assign sine_wave_out[200] = -64276;
   assign sine_wave_out[201] = -63943;
   assign sine_wave_out[202] = -63571;
   assign sine_wave_out[203] = -63162;
   assign sine_wave_out[204] = -62714;
   assign sine_wave_out[205] = -62228;
   assign sine_wave_out[206] = -61705;
   assign sine_wave_out[207] = -61144;
   assign sine_wave_out[208] = -60547;
   assign sine_wave_out[209] = -59913;
   assign sine_wave_out[210] = -59243;
   assign sine_wave_out[211] = -58538;
   assign sine_wave_out[212] = -57797;
   assign sine_wave_out[213] = -57022;
   assign sine_wave_out[214] = -56212;
   assign sine_wave_out[215] = -55368;
   assign sine_wave_out[216] = -54491;
   assign sine_wave_out[217] = -53581;
   assign sine_wave_out[218] = -52639;
   assign sine_wave_out[219] = -51665;
   assign sine_wave_out[220] = -50660;
   assign sine_wave_out[221] = -49624;
   assign sine_wave_out[222] = -48558;
   assign sine_wave_out[223] = -47464;
   assign sine_wave_out[224] = -46340;
   assign sine_wave_out[225] = -45189;
   assign sine_wave_out[226] = -44011;
   assign sine_wave_out[227] = -42806;
   assign sine_wave_out[228] = -41575;
   assign sine_wave_out[229] = -40319;
   assign sine_wave_out[230] = -39039;
   assign sine_wave_out[231] = -37736;
   assign sine_wave_out[232] = -36409;
   assign sine_wave_out[233] = -35061;
   assign sine_wave_out[234] = -33692;
   assign sine_wave_out[235] = -32302;
   assign sine_wave_out[236] = -30893;
   assign sine_wave_out[237] = -29465;
   assign sine_wave_out[238] = -28020;
   assign sine_wave_out[239] = -26557;
   assign sine_wave_out[240] = -25079;
   assign sine_wave_out[241] = -23586;
   assign sine_wave_out[242] = -22078;
   assign sine_wave_out[243] = -20557;
   assign sine_wave_out[244] = -19024;
   assign sine_wave_out[245] = -17479;
   assign sine_wave_out[246] = -15923;
   assign sine_wave_out[247] = -14359;
   assign sine_wave_out[248] = -12785;
   assign sine_wave_out[249] = -11204;
   assign sine_wave_out[250] = -9616;
   assign sine_wave_out[251] = -8022;
   assign sine_wave_out[252] = -6423;
   assign sine_wave_out[253] = -4821;
   assign sine_wave_out[254] = -3215;
   assign sine_wave_out[255] = -1608;
endmodule
`line 8 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_128VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 128
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_128VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:128 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 3215;
   assign sine_wave_out[2] = 6423;
   assign sine_wave_out[3] = 9616;
   assign sine_wave_out[4] = 12785;
   assign sine_wave_out[5] = 15923;
   assign sine_wave_out[6] = 19024;
   assign sine_wave_out[7] = 22078;
   assign sine_wave_out[8] = 25079;
   assign sine_wave_out[9] = 28020;
   assign sine_wave_out[10] = 30893;
   assign sine_wave_out[11] = 33692;
   assign sine_wave_out[12] = 36409;
   assign sine_wave_out[13] = 39039;
   assign sine_wave_out[14] = 41575;
   assign sine_wave_out[15] = 44011;
   assign sine_wave_out[16] = 46340;
   assign sine_wave_out[17] = 48558;
   assign sine_wave_out[18] = 50660;
   assign sine_wave_out[19] = 52639;
   assign sine_wave_out[20] = 54491;
   assign sine_wave_out[21] = 56212;
   assign sine_wave_out[22] = 57797;
   assign sine_wave_out[23] = 59243;
   assign sine_wave_out[24] = 60547;
   assign sine_wave_out[25] = 61705;
   assign sine_wave_out[26] = 62714;
   assign sine_wave_out[27] = 63571;
   assign sine_wave_out[28] = 64276;
   assign sine_wave_out[29] = 64826;
   assign sine_wave_out[30] = 65220;
   assign sine_wave_out[31] = 65457;
   assign sine_wave_out[32] = 65536;
   assign sine_wave_out[33] = 65457;
   assign sine_wave_out[34] = 65220;
   assign sine_wave_out[35] = 64826;
   assign sine_wave_out[36] = 64276;
   assign sine_wave_out[37] = 63571;
   assign sine_wave_out[38] = 62714;
   assign sine_wave_out[39] = 61705;
   assign sine_wave_out[40] = 60547;
   assign sine_wave_out[41] = 59243;
   assign sine_wave_out[42] = 57797;
   assign sine_wave_out[43] = 56212;
   assign sine_wave_out[44] = 54491;
   assign sine_wave_out[45] = 52639;
   assign sine_wave_out[46] = 50660;
   assign sine_wave_out[47] = 48558;
   assign sine_wave_out[48] = 46340;
   assign sine_wave_out[49] = 44011;
   assign sine_wave_out[50] = 41575;
   assign sine_wave_out[51] = 39039;
   assign sine_wave_out[52] = 36409;
   assign sine_wave_out[53] = 33692;
   assign sine_wave_out[54] = 30893;
   assign sine_wave_out[55] = 28020;
   assign sine_wave_out[56] = 25079;
   assign sine_wave_out[57] = 22078;
   assign sine_wave_out[58] = 19024;
   assign sine_wave_out[59] = 15923;
   assign sine_wave_out[60] = 12785;
   assign sine_wave_out[61] = 9616;
   assign sine_wave_out[62] = 6423;
   assign sine_wave_out[63] = 3215;
   assign sine_wave_out[64] = 0;
   assign sine_wave_out[65] = -3215;
   assign sine_wave_out[66] = -6423;
   assign sine_wave_out[67] = -9616;
   assign sine_wave_out[68] = -12785;
   assign sine_wave_out[69] = -15923;
   assign sine_wave_out[70] = -19024;
   assign sine_wave_out[71] = -22078;
   assign sine_wave_out[72] = -25079;
   assign sine_wave_out[73] = -28020;
   assign sine_wave_out[74] = -30893;
   assign sine_wave_out[75] = -33692;
   assign sine_wave_out[76] = -36409;
   assign sine_wave_out[77] = -39039;
   assign sine_wave_out[78] = -41575;
   assign sine_wave_out[79] = -44011;
   assign sine_wave_out[80] = -46340;
   assign sine_wave_out[81] = -48558;
   assign sine_wave_out[82] = -50660;
   assign sine_wave_out[83] = -52639;
   assign sine_wave_out[84] = -54491;
   assign sine_wave_out[85] = -56212;
   assign sine_wave_out[86] = -57797;
   assign sine_wave_out[87] = -59243;
   assign sine_wave_out[88] = -60547;
   assign sine_wave_out[89] = -61705;
   assign sine_wave_out[90] = -62714;
   assign sine_wave_out[91] = -63571;
   assign sine_wave_out[92] = -64276;
   assign sine_wave_out[93] = -64826;
   assign sine_wave_out[94] = -65220;
   assign sine_wave_out[95] = -65457;
   assign sine_wave_out[96] = -65536;
   assign sine_wave_out[97] = -65457;
   assign sine_wave_out[98] = -65220;
   assign sine_wave_out[99] = -64826;
   assign sine_wave_out[100] = -64276;
   assign sine_wave_out[101] = -63571;
   assign sine_wave_out[102] = -62714;
   assign sine_wave_out[103] = -61705;
   assign sine_wave_out[104] = -60547;
   assign sine_wave_out[105] = -59243;
   assign sine_wave_out[106] = -57797;
   assign sine_wave_out[107] = -56212;
   assign sine_wave_out[108] = -54491;
   assign sine_wave_out[109] = -52639;
   assign sine_wave_out[110] = -50660;
   assign sine_wave_out[111] = -48558;
   assign sine_wave_out[112] = -46340;
   assign sine_wave_out[113] = -44011;
   assign sine_wave_out[114] = -41575;
   assign sine_wave_out[115] = -39039;
   assign sine_wave_out[116] = -36409;
   assign sine_wave_out[117] = -33692;
   assign sine_wave_out[118] = -30893;
   assign sine_wave_out[119] = -28020;
   assign sine_wave_out[120] = -25079;
   assign sine_wave_out[121] = -22078;
   assign sine_wave_out[122] = -19024;
   assign sine_wave_out[123] = -15923;
   assign sine_wave_out[124] = -12785;
   assign sine_wave_out[125] = -9616;
   assign sine_wave_out[126] = -6423;
   assign sine_wave_out[127] = -3215;
endmodule
`line 9 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_64VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 64
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_64VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:64 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 6423;
   assign sine_wave_out[2] = 12785;
   assign sine_wave_out[3] = 19024;
   assign sine_wave_out[4] = 25079;
   assign sine_wave_out[5] = 30893;
   assign sine_wave_out[6] = 36409;
   assign sine_wave_out[7] = 41575;
   assign sine_wave_out[8] = 46340;
   assign sine_wave_out[9] = 50660;
   assign sine_wave_out[10] = 54491;
   assign sine_wave_out[11] = 57797;
   assign sine_wave_out[12] = 60547;
   assign sine_wave_out[13] = 62714;
   assign sine_wave_out[14] = 64276;
   assign sine_wave_out[15] = 65220;
   assign sine_wave_out[16] = 65536;
   assign sine_wave_out[17] = 65220;
   assign sine_wave_out[18] = 64276;
   assign sine_wave_out[19] = 62714;
   assign sine_wave_out[20] = 60547;
   assign sine_wave_out[21] = 57797;
   assign sine_wave_out[22] = 54491;
   assign sine_wave_out[23] = 50660;
   assign sine_wave_out[24] = 46340;
   assign sine_wave_out[25] = 41575;
   assign sine_wave_out[26] = 36409;
   assign sine_wave_out[27] = 30893;
   assign sine_wave_out[28] = 25079;
   assign sine_wave_out[29] = 19024;
   assign sine_wave_out[30] = 12785;
   assign sine_wave_out[31] = 6423;
   assign sine_wave_out[32] = 0;
   assign sine_wave_out[33] = -6423;
   assign sine_wave_out[34] = -12785;
   assign sine_wave_out[35] = -19024;
   assign sine_wave_out[36] = -25079;
   assign sine_wave_out[37] = -30893;
   assign sine_wave_out[38] = -36409;
   assign sine_wave_out[39] = -41575;
   assign sine_wave_out[40] = -46340;
   assign sine_wave_out[41] = -50660;
   assign sine_wave_out[42] = -54491;
   assign sine_wave_out[43] = -57797;
   assign sine_wave_out[44] = -60547;
   assign sine_wave_out[45] = -62714;
   assign sine_wave_out[46] = -64276;
   assign sine_wave_out[47] = -65220;
   assign sine_wave_out[48] = -65536;
   assign sine_wave_out[49] = -65220;
   assign sine_wave_out[50] = -64276;
   assign sine_wave_out[51] = -62714;
   assign sine_wave_out[52] = -60547;
   assign sine_wave_out[53] = -57797;
   assign sine_wave_out[54] = -54491;
   assign sine_wave_out[55] = -50660;
   assign sine_wave_out[56] = -46340;
   assign sine_wave_out[57] = -41575;
   assign sine_wave_out[58] = -36409;
   assign sine_wave_out[59] = -30893;
   assign sine_wave_out[60] = -25079;
   assign sine_wave_out[61] = -19024;
   assign sine_wave_out[62] = -12785;
   assign sine_wave_out[63] = -6423;
endmodule
`line 10 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_32VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 32
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_32VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:32 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 12785;
   assign sine_wave_out[2] = 25079;
   assign sine_wave_out[3] = 36409;
   assign sine_wave_out[4] = 46340;
   assign sine_wave_out[5] = 54491;
   assign sine_wave_out[6] = 60547;
   assign sine_wave_out[7] = 64276;
   assign sine_wave_out[8] = 65536;
   assign sine_wave_out[9] = 64276;
   assign sine_wave_out[10] = 60547;
   assign sine_wave_out[11] = 54491;
   assign sine_wave_out[12] = 46340;
   assign sine_wave_out[13] = 36409;
   assign sine_wave_out[14] = 25079;
   assign sine_wave_out[15] = 12785;
   assign sine_wave_out[16] = 0;
   assign sine_wave_out[17] = -12785;
   assign sine_wave_out[18] = -25079;
   assign sine_wave_out[19] = -36409;
   assign sine_wave_out[20] = -46340;
   assign sine_wave_out[21] = -54491;
   assign sine_wave_out[22] = -60547;
   assign sine_wave_out[23] = -64276;
   assign sine_wave_out[24] = -65536;
   assign sine_wave_out[25] = -64276;
   assign sine_wave_out[26] = -60547;
   assign sine_wave_out[27] = -54491;
   assign sine_wave_out[28] = -46340;
   assign sine_wave_out[29] = -36409;
   assign sine_wave_out[30] = -25079;
   assign sine_wave_out[31] = -12785;
endmodule
`line 11 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_16VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 16
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_16VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:16 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 25079;
   assign sine_wave_out[2] = 46340;
   assign sine_wave_out[3] = 60547;
   assign sine_wave_out[4] = 65536;
   assign sine_wave_out[5] = 60547;
   assign sine_wave_out[6] = 46340;
   assign sine_wave_out[7] = 25079;
   assign sine_wave_out[8] = 0;
   assign sine_wave_out[9] = -25079;
   assign sine_wave_out[10] = -46340;
   assign sine_wave_out[11] = -60547;
   assign sine_wave_out[12] = -65536;
   assign sine_wave_out[13] = -60547;
   assign sine_wave_out[14] = -46340;
   assign sine_wave_out[15] = -25079;
endmodule
`line 12 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_8VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 8
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_8VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:8 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 46340;
   assign sine_wave_out[2] = 65536;
   assign sine_wave_out[3] = 46340;
   assign sine_wave_out[4] = 0;
   assign sine_wave_out[5] = -46340;
   assign sine_wave_out[6] = -65536;
   assign sine_wave_out[7] = -46340;
endmodule
`line 13 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_2VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 2
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_2VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:2 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 0;
endmodule
`line 14 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_4VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 4
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_4VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:4 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 65536;
   assign sine_wave_out[2] = 0;
   assign sine_wave_out[3] = -65536;
endmodule
`line 15 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Crossbar/sim/CombinationalFFTCrossbar/CombinationalFFTCrossbarVRTL.v" 0
`ifndef COMBINATIONAL_FFT_CROSSBAR
`define COMBINATIONAL_FFT_CROSSBAR

module CombinationalFFTCrossbarVRTl
   #(
        BIT_WIDTH  = 32,
        SIZE_FFT   = 8 ,
        STAGE_FFT  = 0 ,
        FRONT      = 1 
    )
    (
        input  logic  [BIT_WIDTH - 1:0] recv_real      [SIZE_FFT - 1:0],
        input  logic  [BIT_WIDTH - 1:0] recv_imaginary [SIZE_FFT - 1:0],
        input  logic                    recv_val       [SIZE_FFT - 1:0],
        output logic                    recv_rdy       [SIZE_FFT - 1:0],

        output logic [BIT_WIDTH - 1:0] send_real       [SIZE_FFT - 1:0],
        output logic [BIT_WIDTH - 1:0] send_imaginary  [SIZE_FFT - 1:0],
        output logic                   send_val        [SIZE_FFT - 1:0],
        input  logic                   send_rdy        [SIZE_FFT - 1:0]
    );
    generate
        genvar m;
        for( m = 0; m < 2 ** STAGE_FFT; m = m + 1 ) begin
            genvar i;
            for(i = m; i < SIZE_FFT; i = i + 2 ** ( STAGE_FFT + 1 ) ) begin
                    if(FRONT == 1) begin  
                        assign send_real     [i + m] = recv_real     [i];
                        assign send_imaginary[i + m] = recv_imaginary[i];
                        assign send_val      [i + m] = recv_val      [i];
                        assign recv_rdy      [i + m] = send_rdy      [i];

                        assign send_real     [i + m + 1] = recv_real     [i + 2**STAGE_FFT];
                        assign send_imaginary[i + m + 1] = recv_imaginary[i + 2**STAGE_FFT];
                        assign send_val      [i + m + 1] = recv_val      [i + 2**STAGE_FFT];
                        assign recv_rdy      [i + m + 1] = send_rdy      [i + 2**STAGE_FFT];
                    end else begin  
                        assign send_real     [i] = recv_real     [i + m];
                        assign send_imaginary[i] = recv_imaginary[i + m];
                        assign send_val      [i] = recv_val      [i + m];
                        assign recv_rdy      [i] = send_rdy      [i + m];

                        assign send_real     [i + 2**STAGE_FFT] = recv_real     [i + m + 1];
                        assign send_imaginary[i + 2**STAGE_FFT] = recv_imaginary[i + m + 1];
                        assign send_val      [i + 2**STAGE_FFT] = recv_val      [i + m + 1];
                        assign recv_rdy      [i + 2**STAGE_FFT] = send_rdy      [i + m + 1];
                    end
            end
        end
    endgenerate

endmodule

`endif
`line 16 "../../../FFT/sim/FFT/FFTVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT_StageVRTL.v" 0

`ifndef FFT_STAGE_VRTL
`define FFT_STAGE_VRTL

`line 1 "../../../FFT/sim/FFT/FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/TwiddleGeneratorVRTL.v" 0
`ifndef TWIDDLE_GENERATOR
`define TWIDDLE_GENERATOR
module TwiddleGeneratorVRTL 
   #(
        BIT_WIDTH     = 4,
        DECIMAL_PT    = 2,
        SIZE_FFT      = 8,
        STAGE_FFT     = 0 
    )
    (
        input logic  [BIT_WIDTH - 1:0] sine_wave_in     [0:SIZE_FFT - 1], //sine_wave_in = sin(2*pi m / N)
        
        output logic [BIT_WIDTH - 1:0] twiddle_real     [SIZE_FFT/2 - 1:0],
        output logic [BIT_WIDTH - 1:0] twiddle_imaginary[SIZE_FFT/2 - 1:0]
    );

    int trace;
    assign trace =  1'd1 << DECIMAL_PT;
    int trace2;
    assign trace2 = ( 1 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    int trace3;
    assign trace3 = ( 2 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    int trace4;
    assign trace4 = ( 3 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    generate
        genvar m;
        //if(SIZE_FFT > 2) begin 
            for(m = 0; m < 2 ** STAGE_FFT; m = m + 1) begin
                genvar i;
                for(i = 0; i < SIZE_FFT; i = i + 2 ** (STAGE_FFT + 1) ) begin
                    if(m == 0) begin
                        assign twiddle_real     [i/2 + m] = 1'b1 << DECIMAL_PT;
                        assign twiddle_imaginary[i/2 + m] = 0;
                    end else begin
						assign twiddle_real     [i/2 + m] =  sine_wave_in[(  m * ( SIZE_FFT / ( 2 * (2**STAGE_FFT) ) ) + SIZE_FFT/4) % SIZE_FFT   ];
                        assign twiddle_imaginary[i/2 + m] =  -sine_wave_in[(  ( m * ( SIZE_FFT / ( 2 * (2**STAGE_FFT) ) ) ) % SIZE_FFT )              ];
                    end
                end
            end
        //end else begin
        //    genvar i;
        //    for(i = 0; i < (SIZE_FFT/2) - 1; i++) begin 
        //        assign twiddle_real[i] = 1 << DECIMAL_PT;
        //        assign twiddle_imaginary[i] = 0;
        //    end
        //end
    endgenerate

endmodule

`endif

`line 6 "../../../FFT/sim/FFT/FFT_StageVRTL.v" 0
`line 1 "../../../FFT/sim/FFT/FFT-Crossbar/sim/CombinationalFFTCrossbar/CombinationalFFTCrossbarVRTL.v" 0
`ifndef COMBINATIONAL_FFT_CROSSBAR
`define COMBINATIONAL_FFT_CROSSBAR

module CombinationalFFTCrossbarVRTl
   #(
        BIT_WIDTH  = 32,
        SIZE_FFT   = 8 ,
        STAGE_FFT  = 0 ,
        FRONT      = 1 
    )
    (
        input  logic  [BIT_WIDTH - 1:0] recv_real      [SIZE_FFT - 1:0],
        input  logic  [BIT_WIDTH - 1:0] recv_imaginary [SIZE_FFT - 1:0],
        input  logic                    recv_val       [SIZE_FFT - 1:0],
        output logic                    recv_rdy       [SIZE_FFT - 1:0],

        output logic [BIT_WIDTH - 1:0] send_real       [SIZE_FFT - 1:0],
        output logic [BIT_WIDTH - 1:0] send_imaginary  [SIZE_FFT - 1:0],
        output logic                   send_val        [SIZE_FFT - 1:0],
        input  logic                   send_rdy        [SIZE_FFT - 1:0]
    );
    generate
        genvar m;
        for( m = 0; m < 2 ** STAGE_FFT; m = m + 1 ) begin
            genvar i;
            for(i = m; i < SIZE_FFT; i = i + 2 ** ( STAGE_FFT + 1 ) ) begin
                    if(FRONT == 1) begin  
                        assign send_real     [i + m] = recv_real     [i];
                        assign send_imaginary[i + m] = recv_imaginary[i];
                        assign send_val      [i + m] = recv_val      [i];
                        assign recv_rdy      [i + m] = send_rdy      [i];

                        assign send_real     [i + m + 1] = recv_real     [i + 2**STAGE_FFT];
                        assign send_imaginary[i + m + 1] = recv_imaginary[i + 2**STAGE_FFT];
                        assign send_val      [i + m + 1] = recv_val      [i + 2**STAGE_FFT];
                        assign recv_rdy      [i + m + 1] = send_rdy      [i + 2**STAGE_FFT];
                    end else begin  
                        assign send_real     [i] = recv_real     [i + m];
                        assign send_imaginary[i] = recv_imaginary[i + m];
                        assign send_val      [i] = recv_val      [i + m];
                        assign recv_rdy      [i] = send_rdy      [i + m];

                        assign send_real     [i + 2**STAGE_FFT] = recv_real     [i + m + 1];
                        assign send_imaginary[i + 2**STAGE_FFT] = recv_imaginary[i + m + 1];
                        assign send_val      [i + 2**STAGE_FFT] = recv_val      [i + m + 1];
                        assign recv_rdy      [i + 2**STAGE_FFT] = send_rdy      [i + m + 1];
                    end
            end
        end
    endgenerate

endmodule

`endif
`line 7 "../../../FFT/sim/FFT/FFT_StageVRTL.v" 0
`line 1 "../../../butterfly-unit/sim/butterfly/ButterflyVRTL.v" 0
`ifndef PROJECT_BUTTERFLY_V
`define PROJECT_BUTTERFLY_V
`line 1 "../../../fixedpt-iterative-complex-multiplier/sim/cmultiplier/FpcmultVRTL.v" 0
`ifndef FIXED_POINT_ITERATIVE_COMPLEX_MULTIPLIER
`define FIXED_POINT_ITERATIVE_COMPLEX_MULTIPLIER
`line 1 "../../../fixedpt-iterative-multiplier/sim/multiplier/FpmultVRTL.v" 0
`ifndef FIXED_POINT_ITERATIVE_MULTIPLIER
`define FIXED_POINT_ITERATIVE_MULTIPLIER

`line 1 "../../../fixedpt-iterative-multiplier/sim/multiplier/muxes.v" 0
//========================================================================
// Verilog Components: Muxes
//========================================================================

`ifndef VC_MUXES_V
`define VC_MUXES_V

//------------------------------------------------------------------------
// 2 Input Mux
//------------------------------------------------------------------------

module vc_Mux2
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1,
  input  logic               sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      1'd0 : out = in0;
      1'd1 : out = in1;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 3 Input Mux
//------------------------------------------------------------------------

module vc_Mux3
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 4 Input Mux
//------------------------------------------------------------------------

module vc_Mux4
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      2'd3 : out = in3;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 5 Input Mux
//------------------------------------------------------------------------

module vc_Mux5
#(
 parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 6 Input Mux
//------------------------------------------------------------------------

module vc_Mux6
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 7 Input Mux
//------------------------------------------------------------------------

module vc_Mux7
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 8 Input Mux
//------------------------------------------------------------------------

module vc_Mux8
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6, in7,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      3'd7 : out = in7;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// N Input Mux
//------------------------------------------------------------------------

module vc_MuxN
#(
  parameter p_nbits = 1,
  parameter p_ninputs = 2
)(
  input  logic [p_ninputs-1:0][p_nbits-1:0] in,
  input  logic [$clog2(p_ninputs)-1:0]      sel,
  output logic [p_nbits-1:0]                out
);

  assign out = in[sel];

endmodule

`endif /* VC_MUXES_V */


`line 5 "../../../fixedpt-iterative-multiplier/sim/multiplier/FpmultVRTL.v" 0
`line 1 "../../../fixedpt-iterative-multiplier/sim/multiplier/RegisterV_Reset.v" 0
`ifndef PROJECT_REGISTER_V_RESET
`define PROJECT_REGISTER_V_RESET

module RegisterV_Reset
	#(parameter N = 8)
	(clk, reset, w, d, q);
    input logic clk;
    input logic reset;
    input  logic w;
    input logic [N-1:0] d;
    output logic [N-1:0] q;
    logic [N-1:0] regout;

    assign q = regout;

    always @(posedge clk) begin
	if (reset)
	    regout <= 0;
	else if (w)
	    regout <= d;
        
    end
endmodule

`endif

`line 6 "../../../fixedpt-iterative-multiplier/sim/multiplier/FpmultVRTL.v" 0

module FpmultVRTL
# (
	parameter n = 32, // bit width
	parameter d = 16, // number of decimal bits
	parameter sign = 1 // 1 if signed, 0 otherwise.
) (clk, reset, recv_val, recv_rdy, send_val, send_rdy, a, b, c);
	// performs the operation c = a*b
	// Equivalent to taking the integer representations of both numbers,
	// multiplying, and then shifting right
	input logic clk, reset;
	input logic recv_val, send_rdy;
	input logic [n-1:0] a, b;
	output logic [n-1:0] c;
	output logic send_val, recv_rdy;

	logic do_carry, do_add, in_wait;

	fpmult_control #(n, d) control (
		.clk(clk),
		.reset(reset),
		.recv_val(recv_val),
		.recv_rdy(recv_rdy),
		.send_val(send_val),
		.send_rdy(send_rdy),
		.in_wait(in_wait),
		.do_add(do_add),
		.do_carry(do_carry)
	);

	fpmult_datapath #(n, d) datapath (
		.clk(clk),
		.reset(reset),
		.in_wait(in_wait),
		.do_add(do_add),
		.do_carry((sign != 0) & do_carry),
		.a({ {d{(sign != 0) & a[n-1]}}, a }),
		.b(b),
		.c(c)
	);

endmodule

module fpmult_control
# (
	parameter n, parameter d
) (
	input logic clk,
	input logic reset,
	input logic recv_val,
	output logic recv_rdy,
	output logic send_val,
	input logic send_rdy,
	output logic in_wait,
	output logic do_add,
	output logic do_carry
);

	localparam [1:0]
		IDLE = 2'd0,
		CALC = 2'd1,
		DONE = 2'd2;

	logic [1:0] state, next_state;
	logic [$clog2(n)-1:0] counter;
	logic counter_reset;
	
	// manage state
	always @(*) begin
		case (state)
			IDLE: begin
				if (recv_val) next_state = CALC;
				else next_state = IDLE;
			end
			CALC: begin
				if (counter == ($clog2(n))'(n-1)) next_state = DONE;
				else next_state = CALC;
			end
			DONE: begin
				if (send_rdy) next_state = IDLE;
				else next_state = DONE;
			end
			default: begin
				next_state = IDLE;
			end
		endcase
	end

	// manage datapath
	always @(*) begin
		case (state)
			IDLE: begin
				in_wait = 1; do_add = 0; do_carry = 0; counter_reset = 0;
				recv_rdy = 1; send_val = 0;
			end
			CALC: begin
				in_wait = 0; do_add = 1; do_carry = (counter == ($clog2(n))'(n-1)); counter_reset = 0;
				recv_rdy = 0; send_val = 0;
			end
			DONE: begin
				in_wait = 0; do_add = 0; do_carry = 0; counter_reset = 1;
				recv_rdy = 0; send_val = 1;
			end
			default: begin
			end
		endcase
	end

	// reset logic
	always @(posedge clk) begin
		if (reset) begin
			state <= IDLE;
		end else begin
			state <= next_state;
		end
	end

	// counter logic
	always @(posedge clk) begin
		if (reset || counter_reset) begin
			counter <= 0;
		end else if (state == CALC) begin
			counter <= counter + 1;
		end else begin
			counter <= counter;
		end
	end
	
endmodule

module fpmult_datapath
# (
	parameter n, parameter d
) (
	input logic clk,
	input logic reset,
	input logic in_wait, // waiting for input
	input logic do_add,
	input logic do_carry,
	input logic [n+d-1:0] a,
	input logic [n-1:0] b,
	output logic [n-1:0] c
);

	logic [(n+d)-1:0] acc_in;
	logic [(n+d)-1:0] acc_out;
	
	RegisterV_Reset #(n+d) acc_reg (
		.clk(clk),
		.reset(in_wait | reset),
		.w(1),
		.d(acc_in),
		.q(acc_out)
	);

	logic [(n+d)-1:0] a_const_out;

	RegisterV_Reset #(n+d) a_const_reg (
		.clk(clk),
		.reset(reset),
		.w(in_wait),
		.d(a),
		.q(a_const_out)
	);

	logic [(n+d)-1:0] a_in;
	logic [(n+d)-1:0] a_out;

	RegisterV_Reset #(n+d) a_reg (
		.clk(clk),
		.reset(reset),
		.w(1),
		.d(a_in),
		.q(a_out)
	);

	logic [(n+d)-1:0] b_in;
	logic [(n+d)-1:0] b_out;

	RegisterV_Reset #(n) b_reg (
		.clk(clk),
		.reset(reset),
		.w(1),
		.d(b_in),
		.q(b_out)
	);

	vc_Mux2 #(n+d) a_sel (
		.in0(a_out << 1),
		.in1(a),
		.sel(in_wait),
		.out(a_in)
	);

	vc_Mux2 #(n) b_sel (
		.in0(b_out >> 1),
		.in1(b),
		.sel(in_wait),
		.out(b_in)
	);

	logic [n+d-1:0] add_tmp;
	logic [n+d-1:0] carry;

	logic [2*n-1:0] carry_tmp, carry_tmp2;
	assign carry_tmp = { {(n-d){a_const_out[n+d-1]}}, a_const_out}; // sign extend a
	assign carry_tmp2 = ((carry_tmp << n) - carry_tmp) << (n-1);

	vc_Mux2 #(n+d) carry_sel (
		.in0(a_out),
		.in1(carry_tmp2[n+d-1:0]),
		.sel(do_carry),
		.out(add_tmp)
	);

	vc_Mux2 #(n+d) add_sel (
		.in0(acc_out),
		.in1(acc_out + add_tmp),
		.sel(do_add & b_out[0]),
		.out(acc_in)
	);

	assign c = acc_out[n+d-1:d];
endmodule

`endif

`line 4 "../../../fixedpt-iterative-complex-multiplier/sim/cmultiplier/FpcmultVRTL.v" 0

module FpcmultVRTL
# (
	parameter n = 32, // bit width
	parameter d = 16 // number of decimal bits
) (
	input logic clk,
	input logic reset,
	input logic recv_val,
	output logic recv_rdy,
	output logic send_val,
	input logic send_rdy,
	input logic [n-1:0] ar,
	input logic [n-1:0] ac,
	input logic [n-1:0] br,
	input logic [n-1:0] bc,
	output logic [n-1:0] cr,
	output logic [n-1:0] cc
);
	// performs c = a * b on complex a and b

	// cr = (ar * br) - (ac * bc)
	// cc = (ar * bc) + (br * ac) = (ar + ac)(br + bc) - (ac * bc) - (ar * br)
	
	logic [n - 1:0] arbr;
	logic [n - 1:0] acbc;
	logic [n - 1:0] ar_plus_ac;
	logic [n - 1:0] br_plus_bc;
	logic [n - 1:0] ab;

	assign ar_plus_ac = ar + ac;
	assign br_plus_bc = br + bc;

	logic recv_rdy_imm [2:0];
	assign recv_rdy = recv_rdy_imm[0] & recv_rdy_imm[1] & recv_rdy_imm[2];

	logic send_val_imm [2:0];
	assign send_val = send_val_imm[0] & send_val_imm[1] & send_val_imm[2];


	FpmultVRTL #(.n(n), .d(d), .sign(1)) m1 ( // ar * br
		.clk(clk),
		.reset(reset),
		.a(ar),
		.b(br),
		.c(arbr),
		.recv_val(recv_val),
		.recv_rdy(recv_rdy_imm[0]),
		.send_val(send_val_imm[0]),
		.send_rdy(send_rdy)
	);

	FpmultVRTL #(.n(n), .d(d), .sign(1)) m2 ( // ac * bc
		.clk(clk),
		.reset(reset),
		.a(ac),
		.b(bc),
		.c(acbc),
		.recv_val(recv_val),
		.recv_rdy(recv_rdy_imm[1]),
		.send_val(send_val_imm[1]),
		.send_rdy(send_rdy)
	);

	FpmultVRTL #(.n(n), .d(d), .sign(1)) m3 ( // (ar + ac) * (br + bc)
		.clk(clk),
		.reset(reset),
		.a(ar_plus_ac),
		.b(br_plus_bc),
		.c(ab),
		.recv_val(recv_val),
		.recv_rdy(recv_rdy_imm[2]),
		.send_val(send_val_imm[2]),
		.send_rdy(send_rdy)
	);



	assign cr = arbr - acbc;
	assign cc = ab - arbr - acbc;


endmodule

`endif

`line 4 "../../../butterfly-unit/sim/butterfly/ButterflyVRTL.v" 0
`line 1 "../../../butterfly-unit/sim/butterfly/RegisterV.v" 0
`ifndef REGISTER_V
`define REGISTER_V

module RegisterV
	#(parameter BIT_WIDTH = 32)
	(clk, reset, w, d, q);

	input logic clk;
	input logic reset;
	input  logic w;
	input logic [BIT_WIDTH-1:0] d;
	output logic [BIT_WIDTH-1:0] q;
	logic [BIT_WIDTH-1:0] regout;

	assign q = regout;

	always @(posedge clk) begin
		if (w)
			regout <= d;
	end
endmodule

`endif

`line 5 "../../../butterfly-unit/sim/butterfly/ButterflyVRTL.v" 0

module ButterflyVRTL

#(
	parameter n = 32,
	parameter d = 16,
	parameter mult = 0
	// Optimization parameter to save area:
	// 0 if we include the multiplier
	// 1 if omega = 1
	// 2 if omega = -1
	// 3 if omega = i (j)
	// 4 if omega = -i (-j)
) (clk, reset, recv_val, recv_rdy, send_val, send_rdy, ar, ac, br, bc, wr, wc, cr, cc, dr, dc);
	/* performs the butterfly operation, equivalent to doing
		| 1  w |   | a |   | c |
		| 1 -w | * | b | = | d |
	*/

	input logic clk, reset;
	input logic recv_val, send_rdy;
	input logic [n-1:0] ar, ac, br, bc, wr, wc;
	output logic send_val, recv_rdy;
	output logic [n-1:0] cr, cc, dr, dc;

	logic [n-1:0] ar_imm, ac_imm;

	logic [n-1:0] tr, tc;
	generate
		if (mult == 1) begin
			always @(posedge clk) begin
				if (reset) begin
					cr = 0; cc = 0; dr = 0; dc = 0;
					send_val = 0;
				end else if (recv_val & recv_rdy) begin
					cr = ar + br; cc = ac + bc; dr = ar - br; dc = ac - bc;
					send_val = 1;
				end else if (send_val & send_rdy) begin
					send_val = 0;
				end else begin
					cr = cr; cc = cc; dr = dr; dc = dc;
					send_val = send_val;
				end
			end
			assign recv_rdy = ~send_val;
		end else if (mult == 2) begin
			always @(posedge clk) begin
				if (reset) begin
					cr = 0; cc = 0; dr = 0; dc = 0;
					send_val = 0;
				end else if (recv_val & recv_rdy) begin
					cr = ar - br; cc = ac - bc; dr = ar + br; dc = ac + bc;
					send_val = 1;
				end else if (send_val & send_rdy) begin
					send_val = 0;
				end else begin
					cr = cr; cc = cc; dr = dr; dc = dc;
					send_val = send_val;
				end
			end
			assign recv_rdy = ~send_val;
		end else if (mult == 3) begin
			always @(posedge clk) begin
				if (reset) begin
					cr = 0; cc = 0; dr = 0; dc = 0;
					send_val = 0;
				end else if (recv_val & recv_rdy) begin
					cr = ar - bc; cc = ac + br; dr = ar + bc; dc = ac - br;
					send_val = 1;
				end else if (send_val & send_rdy) begin
					send_val = 0;
				end else begin
					cr = cr; cc = cc; dr = dr; dc = dc;
					send_val = send_val;
				end
			end
			assign recv_rdy = ~send_val;
		end else if (mult == 4) begin
			always @(posedge clk) begin
				if (reset) begin
					cr = 0; cc = 0; dr = 0; dc = 0;
					send_val = 0;
				end else if (recv_val & recv_rdy) begin
					cr = ar + bc; cc = ac - br; dr = ar - bc; dc = ac + br;
					send_val = 1;
				end else if (send_val & send_rdy) begin
					send_val = 0;
				end else begin
					cr = cr; cc = cc; dr = dr; dc = dc;
					send_val = send_val;
				end
			end
			assign recv_rdy = ~send_val;
		end else begin
			FpcmultVRTL #(.n(n), .d(d)) mul ( // ar * br
				.clk(clk),
				.reset(reset),
				.ar(br),
				.ac(bc),
				.br(wr),
				.bc(wc),
				.cr(tr),
				.cc(tc),
				.recv_val(recv_val),
				.recv_rdy(recv_rdy),
				.send_val(send_val),
				.send_rdy(send_rdy)
			);
			RegisterV #(.BIT_WIDTH(n)) ac_reg(.clk(clk), .w(recv_rdy), .d(ac), .q(ac_imm), .reset(reset)); //TODO make register resettable
			RegisterV #(.BIT_WIDTH(n)) ar_reg(.clk(clk), .w(recv_rdy), .d(ar), .q(ar_imm), .reset(reset)); //TODO make register resettable

			
		end
	endgenerate
	
	assign cr = ar_imm + tr;
	assign cc = ac_imm + tc;
	assign dr = ar_imm - tr;
	assign dc = ac_imm - tc;				

	
endmodule
`endif

`line 8 "../../../FFT/sim/FFT/FFT_StageVRTL.v" 0



module FFT_StageVRTL
    #(
        BIT_WIDTH  = 32,
        DECIMAL_PT = 16,
        N_SAMPLES  = 8,
        STAGE_FFT  = 0
    )
    (
        input  logic [BIT_WIDTH - 1:0] recv_msg_real [N_SAMPLES - 1:0],
        input  logic [BIT_WIDTH - 1:0] recv_msg_imag [N_SAMPLES - 1:0],
        input  logic                   recv_val                  ,
        output logic                   recv_rdy                  ,

        output logic [BIT_WIDTH - 1:0] send_msg_real [N_SAMPLES - 1:0],
        output logic [BIT_WIDTH - 1:0] send_msg_imag [N_SAMPLES - 1:0],
        output logic                   send_val                  ,
        input  logic                   send_rdy                  ,

        input  logic [BIT_WIDTH - 1:0] sine_wave_out [0:N_SAMPLES - 1],

        input  logic                   reset                     ,
        input  logic                   clk
    );


    logic                   val_in         [N_SAMPLES - 1:0];
    logic                   rdy_in         [N_SAMPLES - 1:0];

    logic                   val_out        [N_SAMPLES - 1:0];
    logic                   rdy_out        [N_SAMPLES - 1:0];

    logic [N_SAMPLES - 1:0] imm;
    always @(*) begin
        int i;
        for(i = 0; i < N_SAMPLES; i++) begin

            
            val_in[i] = recv_val;
            imm[i] = rdy_in[i];
        end
        recv_rdy = &imm;
    end

    
    logic [BIT_WIDTH - 1:0] butterfly_in_real       [N_SAMPLES - 1:0];
    logic [BIT_WIDTH - 1:0] butterfly_out_real      [N_SAMPLES - 1:0];
    logic [BIT_WIDTH - 1:0] butterfly_in_imaginary  [N_SAMPLES - 1:0];
    logic [BIT_WIDTH - 1:0] butterfly_out_imaginary [N_SAMPLES - 1:0];

    logic                   val_interior_in         [N_SAMPLES - 1:0];
    logic                   rdy_interior_in         [N_SAMPLES - 1:0];
    logic                   val_interior_out        [N_SAMPLES - 1:0];
    logic                   rdy_interior_out        [N_SAMPLES - 1:0];

    logic [BIT_WIDTH - 1:0] twiddle_real            [N_SAMPLES/2 - 1:0];
    logic [BIT_WIDTH - 1:0] twiddle_imaginary       [N_SAMPLES/2 - 1:0];

    logic                   val_interior_mini       [N_SAMPLES/2 - 1:0];
    logic                   rdy_interior_mini       [N_SAMPLES/2 - 1:0];

    CombinationalFFTCrossbarVRTl #(.BIT_WIDTH(BIT_WIDTH),                          .SIZE_FFT(N_SAMPLES),                                     .STAGE_FFT(STAGE_FFT),              .FRONT(1)) xbar_in_1
                                  (.recv_real(recv_msg_real),                   .recv_imaginary(recv_msg_imag),                        .recv_val(val_in),       .recv_rdy(rdy_in), 
                                   .send_real(butterfly_in_real[N_SAMPLES - 1:0]), .send_imaginary(butterfly_in_imaginary[N_SAMPLES - 1:0]), .send_val(val_interior_in), .send_rdy(rdy_interior_in));

    generate
        genvar b;    
        for( b = 0; b < N_SAMPLES/2; b++) begin
			localparam IX =
				(b%(2**STAGE_FFT))*(N_SAMPLES/(2*(2**STAGE_FFT)));

			localparam MMC =
				((IX==0)? 1 : (IX==N_SAMPLES/2)? 2 : (IX==N_SAMPLES/4)? 4 : (IX==3*N_SAMPLES/4)? 3 : 0);

            ButterflyVRTL #( .n(BIT_WIDTH), .d(DECIMAL_PT) ,
			.mult(MMC)) bfu_in ( .ar(butterfly_in_real[ b * 2     ]), .ac(butterfly_in_imaginary[ b * 2     ]), 
                                                                      .br(butterfly_in_real[(b * 2) + 1]), .bc(butterfly_in_imaginary[(b * 2) + 1]), 
                                                                      .wr(twiddle_real     [b]),           .wc(twiddle_imaginary     [b]          ),
                                                                      .recv_val(val_interior_in[b * 2] && val_interior_in[(b * 2) + 1]), .recv_rdy(rdy_interior_mini[b]),
                                                                      .cr(butterfly_out_real[b * 2]),       .cc(butterfly_out_imaginary[b * 2]), 
                                                                      .dr(butterfly_out_real[(b * 2) + 1]), .dc(butterfly_out_imaginary[(b * 2) + 1]),
                                                                      .send_rdy(send_val && rdy_interior_out[b * 2] && rdy_interior_out[(b * 2) + 1]), .send_val(val_interior_mini[b]),
                                                                      .reset(reset), .clk(clk));


        

        assign val_interior_out[(b * 2) + 1] = val_interior_mini[b]; //
        assign val_interior_out[b * 2]       = val_interior_mini[b];

        assign rdy_interior_in [(b * 2) + 1] = rdy_interior_mini[b];
        assign rdy_interior_in [b * 2]       = rdy_interior_mini[b];
        end
    endgenerate

    

    CombinationalFFTCrossbarVRTl #(.BIT_WIDTH(BIT_WIDTH), .SIZE_FFT(N_SAMPLES), .STAGE_FFT(STAGE_FFT), .FRONT(0)) xbar_out_1
                                  (.recv_real(butterfly_out_real), .recv_imaginary(butterfly_out_imaginary), .recv_val(val_interior_out),   .recv_rdy(rdy_interior_out), 
                                       .send_real(send_msg_real),    .send_imaginary(send_msg_imag),      .send_val(val_out), .send_rdy(rdy_out));    

    TwiddleGeneratorVRTL #( .BIT_WIDTH(BIT_WIDTH), .DECIMAL_PT(DECIMAL_PT), .SIZE_FFT(N_SAMPLES), .STAGE_FFT(STAGE_FFT) ) twiddle_generator ( .sine_wave_in(sine_wave_out), .twiddle_real(twiddle_real), .twiddle_imaginary(twiddle_imaginary) );
    
    logic [N_SAMPLES - 1:0] imm2;
	logic imm2reset;
    always @(*) begin
        int i;
        for (i = 0; i < N_SAMPLES; i++) begin
			imm2[i] = val_out[i];
//            imm2[i] = ~imm2reset & (imm2[i] | val_out[i]);
            rdy_out[i] = send_rdy;

        end
        send_val = &imm2;
    end

	always @(posedge clk) begin
		int i;
		for (i = 0; i < N_SAMPLES; i++) begin
			if (send_val & send_rdy) begin
				imm2reset <= 1;
			end else begin
				imm2reset <= 0;
			end
		end
	end
endmodule

`endif
`line 17 "../../../FFT/sim/FFT/FFTVRTL.v" 0
module FFTVRTL 
   #(
        BIT_WIDTH  = 32,
        DECIMAL_PT = 16,
        N_SAMPLES  = 8
    )
    (
        input  logic [BIT_WIDTH - 1:0] recv_msg [N_SAMPLES - 1:0],
        input  logic                   recv_val                  ,
        output logic                   recv_rdy                  ,

        output logic [BIT_WIDTH - 1:0] send_msg [N_SAMPLES - 1:0],
        output logic                   send_val                  ,
        input  logic                   send_rdy                  ,

        input  logic                   reset                     ,
        input  logic                   clk
    );

    logic [BIT_WIDTH - 1:0] real_msg       [$clog2(N_SAMPLES):0][N_SAMPLES - 1:0];
    logic [BIT_WIDTH - 1:0] complex_msg    [$clog2(N_SAMPLES):0][N_SAMPLES - 1:0];

    logic                   val_in         [$clog2(N_SAMPLES):0];
    logic                   rdy_in         [$clog2(N_SAMPLES):0];

    logic [BIT_WIDTH - 1:0] sine_wave_out [0:N_SAMPLES - 1];


    assign val_in  [0] = recv_val;
    assign recv_rdy    = rdy_in[0];

    assign send_val                  = val_in     [$clog2(N_SAMPLES)];
    assign rdy_in[$clog2(N_SAMPLES)] = send_rdy;

    


    always @(*) begin
        int i;
        for(i = 0; i < N_SAMPLES; i++) begin
            complex_msg[0][i] = 0;
        end
    end

    //Manual 8-bit bit reversal TODO make parametrized
    generate
        if(N_SAMPLES == 512) begin
            assign real_msg[0][0] = recv_msg[0];
            assign real_msg[0][256] = recv_msg[1];
            assign real_msg[0][128] = recv_msg[2];
            assign real_msg[0][384] = recv_msg[3];
            assign real_msg[0][64] = recv_msg[4];
            assign real_msg[0][320] = recv_msg[5];
            assign real_msg[0][192] = recv_msg[6];
            assign real_msg[0][448] = recv_msg[7];
            assign real_msg[0][32] = recv_msg[8];
            assign real_msg[0][288] = recv_msg[9];
            assign real_msg[0][160] = recv_msg[10];
            assign real_msg[0][416] = recv_msg[11];
            assign real_msg[0][96] = recv_msg[12];
            assign real_msg[0][352] = recv_msg[13];
            assign real_msg[0][224] = recv_msg[14];
            assign real_msg[0][480] = recv_msg[15];
            assign real_msg[0][16] = recv_msg[16];
            assign real_msg[0][272] = recv_msg[17];
            assign real_msg[0][144] = recv_msg[18];
            assign real_msg[0][400] = recv_msg[19];
            assign real_msg[0][80] = recv_msg[20];
            assign real_msg[0][336] = recv_msg[21];
            assign real_msg[0][208] = recv_msg[22];
            assign real_msg[0][464] = recv_msg[23];
            assign real_msg[0][48] = recv_msg[24];
            assign real_msg[0][304] = recv_msg[25];
            assign real_msg[0][176] = recv_msg[26];
            assign real_msg[0][432] = recv_msg[27];
            assign real_msg[0][112] = recv_msg[28];
            assign real_msg[0][368] = recv_msg[29];
            assign real_msg[0][240] = recv_msg[30];
            assign real_msg[0][496] = recv_msg[31];
            assign real_msg[0][8] = recv_msg[32];
            assign real_msg[0][264] = recv_msg[33];
            assign real_msg[0][136] = recv_msg[34];
            assign real_msg[0][392] = recv_msg[35];
            assign real_msg[0][72] = recv_msg[36];
            assign real_msg[0][328] = recv_msg[37];
            assign real_msg[0][200] = recv_msg[38];
            assign real_msg[0][456] = recv_msg[39];
            assign real_msg[0][40] = recv_msg[40];
            assign real_msg[0][296] = recv_msg[41];
            assign real_msg[0][168] = recv_msg[42];
            assign real_msg[0][424] = recv_msg[43];
            assign real_msg[0][104] = recv_msg[44];
            assign real_msg[0][360] = recv_msg[45];
            assign real_msg[0][232] = recv_msg[46];
            assign real_msg[0][488] = recv_msg[47];
            assign real_msg[0][24] = recv_msg[48];
            assign real_msg[0][280] = recv_msg[49];
            assign real_msg[0][152] = recv_msg[50];
            assign real_msg[0][408] = recv_msg[51];
            assign real_msg[0][88] = recv_msg[52];
            assign real_msg[0][344] = recv_msg[53];
            assign real_msg[0][216] = recv_msg[54];
            assign real_msg[0][472] = recv_msg[55];
            assign real_msg[0][56] = recv_msg[56];
            assign real_msg[0][312] = recv_msg[57];
            assign real_msg[0][184] = recv_msg[58];
            assign real_msg[0][440] = recv_msg[59];
            assign real_msg[0][120] = recv_msg[60];
            assign real_msg[0][376] = recv_msg[61];
            assign real_msg[0][248] = recv_msg[62];
            assign real_msg[0][504] = recv_msg[63];
            assign real_msg[0][4] = recv_msg[64];
            assign real_msg[0][260] = recv_msg[65];
            assign real_msg[0][132] = recv_msg[66];
            assign real_msg[0][388] = recv_msg[67];
            assign real_msg[0][68] = recv_msg[68];
            assign real_msg[0][324] = recv_msg[69];
            assign real_msg[0][196] = recv_msg[70];
            assign real_msg[0][452] = recv_msg[71];
            assign real_msg[0][36] = recv_msg[72];
            assign real_msg[0][292] = recv_msg[73];
            assign real_msg[0][164] = recv_msg[74];
            assign real_msg[0][420] = recv_msg[75];
            assign real_msg[0][100] = recv_msg[76];
            assign real_msg[0][356] = recv_msg[77];
            assign real_msg[0][228] = recv_msg[78];
            assign real_msg[0][484] = recv_msg[79];
            assign real_msg[0][20] = recv_msg[80];
            assign real_msg[0][276] = recv_msg[81];
            assign real_msg[0][148] = recv_msg[82];
            assign real_msg[0][404] = recv_msg[83];
            assign real_msg[0][84] = recv_msg[84];
            assign real_msg[0][340] = recv_msg[85];
            assign real_msg[0][212] = recv_msg[86];
            assign real_msg[0][468] = recv_msg[87];
            assign real_msg[0][52] = recv_msg[88];
            assign real_msg[0][308] = recv_msg[89];
            assign real_msg[0][180] = recv_msg[90];
            assign real_msg[0][436] = recv_msg[91];
            assign real_msg[0][116] = recv_msg[92];
            assign real_msg[0][372] = recv_msg[93];
            assign real_msg[0][244] = recv_msg[94];
            assign real_msg[0][500] = recv_msg[95];
            assign real_msg[0][12] = recv_msg[96];
            assign real_msg[0][268] = recv_msg[97];
            assign real_msg[0][140] = recv_msg[98];
            assign real_msg[0][396] = recv_msg[99];
            assign real_msg[0][76] = recv_msg[100];
            assign real_msg[0][332] = recv_msg[101];
            assign real_msg[0][204] = recv_msg[102];
            assign real_msg[0][460] = recv_msg[103];
            assign real_msg[0][44] = recv_msg[104];
            assign real_msg[0][300] = recv_msg[105];
            assign real_msg[0][172] = recv_msg[106];
            assign real_msg[0][428] = recv_msg[107];
            assign real_msg[0][108] = recv_msg[108];
            assign real_msg[0][364] = recv_msg[109];
            assign real_msg[0][236] = recv_msg[110];
            assign real_msg[0][492] = recv_msg[111];
            assign real_msg[0][28] = recv_msg[112];
            assign real_msg[0][284] = recv_msg[113];
            assign real_msg[0][156] = recv_msg[114];
            assign real_msg[0][412] = recv_msg[115];
            assign real_msg[0][92] = recv_msg[116];
            assign real_msg[0][348] = recv_msg[117];
            assign real_msg[0][220] = recv_msg[118];
            assign real_msg[0][476] = recv_msg[119];
            assign real_msg[0][60] = recv_msg[120];
            assign real_msg[0][316] = recv_msg[121];
            assign real_msg[0][188] = recv_msg[122];
            assign real_msg[0][444] = recv_msg[123];
            assign real_msg[0][124] = recv_msg[124];
            assign real_msg[0][380] = recv_msg[125];
            assign real_msg[0][252] = recv_msg[126];
            assign real_msg[0][508] = recv_msg[127];
            assign real_msg[0][2] = recv_msg[128];
            assign real_msg[0][258] = recv_msg[129];
            assign real_msg[0][130] = recv_msg[130];
            assign real_msg[0][386] = recv_msg[131];
            assign real_msg[0][66] = recv_msg[132];
            assign real_msg[0][322] = recv_msg[133];
            assign real_msg[0][194] = recv_msg[134];
            assign real_msg[0][450] = recv_msg[135];
            assign real_msg[0][34] = recv_msg[136];
            assign real_msg[0][290] = recv_msg[137];
            assign real_msg[0][162] = recv_msg[138];
            assign real_msg[0][418] = recv_msg[139];
            assign real_msg[0][98] = recv_msg[140];
            assign real_msg[0][354] = recv_msg[141];
            assign real_msg[0][226] = recv_msg[142];
            assign real_msg[0][482] = recv_msg[143];
            assign real_msg[0][18] = recv_msg[144];
            assign real_msg[0][274] = recv_msg[145];
            assign real_msg[0][146] = recv_msg[146];
            assign real_msg[0][402] = recv_msg[147];
            assign real_msg[0][82] = recv_msg[148];
            assign real_msg[0][338] = recv_msg[149];
            assign real_msg[0][210] = recv_msg[150];
            assign real_msg[0][466] = recv_msg[151];
            assign real_msg[0][50] = recv_msg[152];
            assign real_msg[0][306] = recv_msg[153];
            assign real_msg[0][178] = recv_msg[154];
            assign real_msg[0][434] = recv_msg[155];
            assign real_msg[0][114] = recv_msg[156];
            assign real_msg[0][370] = recv_msg[157];
            assign real_msg[0][242] = recv_msg[158];
            assign real_msg[0][498] = recv_msg[159];
            assign real_msg[0][10] = recv_msg[160];
            assign real_msg[0][266] = recv_msg[161];
            assign real_msg[0][138] = recv_msg[162];
            assign real_msg[0][394] = recv_msg[163];
            assign real_msg[0][74] = recv_msg[164];
            assign real_msg[0][330] = recv_msg[165];
            assign real_msg[0][202] = recv_msg[166];
            assign real_msg[0][458] = recv_msg[167];
            assign real_msg[0][42] = recv_msg[168];
            assign real_msg[0][298] = recv_msg[169];
            assign real_msg[0][170] = recv_msg[170];
            assign real_msg[0][426] = recv_msg[171];
            assign real_msg[0][106] = recv_msg[172];
            assign real_msg[0][362] = recv_msg[173];
            assign real_msg[0][234] = recv_msg[174];
            assign real_msg[0][490] = recv_msg[175];
            assign real_msg[0][26] = recv_msg[176];
            assign real_msg[0][282] = recv_msg[177];
            assign real_msg[0][154] = recv_msg[178];
            assign real_msg[0][410] = recv_msg[179];
            assign real_msg[0][90] = recv_msg[180];
            assign real_msg[0][346] = recv_msg[181];
            assign real_msg[0][218] = recv_msg[182];
            assign real_msg[0][474] = recv_msg[183];
            assign real_msg[0][58] = recv_msg[184];
            assign real_msg[0][314] = recv_msg[185];
            assign real_msg[0][186] = recv_msg[186];
            assign real_msg[0][442] = recv_msg[187];
            assign real_msg[0][122] = recv_msg[188];
            assign real_msg[0][378] = recv_msg[189];
            assign real_msg[0][250] = recv_msg[190];
            assign real_msg[0][506] = recv_msg[191];
            assign real_msg[0][6] = recv_msg[192];
            assign real_msg[0][262] = recv_msg[193];
            assign real_msg[0][134] = recv_msg[194];
            assign real_msg[0][390] = recv_msg[195];
            assign real_msg[0][70] = recv_msg[196];
            assign real_msg[0][326] = recv_msg[197];
            assign real_msg[0][198] = recv_msg[198];
            assign real_msg[0][454] = recv_msg[199];
            assign real_msg[0][38] = recv_msg[200];
            assign real_msg[0][294] = recv_msg[201];
            assign real_msg[0][166] = recv_msg[202];
            assign real_msg[0][422] = recv_msg[203];
            assign real_msg[0][102] = recv_msg[204];
            assign real_msg[0][358] = recv_msg[205];
            assign real_msg[0][230] = recv_msg[206];
            assign real_msg[0][486] = recv_msg[207];
            assign real_msg[0][22] = recv_msg[208];
            assign real_msg[0][278] = recv_msg[209];
            assign real_msg[0][150] = recv_msg[210];
            assign real_msg[0][406] = recv_msg[211];
            assign real_msg[0][86] = recv_msg[212];
            assign real_msg[0][342] = recv_msg[213];
            assign real_msg[0][214] = recv_msg[214];
            assign real_msg[0][470] = recv_msg[215];
            assign real_msg[0][54] = recv_msg[216];
            assign real_msg[0][310] = recv_msg[217];
            assign real_msg[0][182] = recv_msg[218];
            assign real_msg[0][438] = recv_msg[219];
            assign real_msg[0][118] = recv_msg[220];
            assign real_msg[0][374] = recv_msg[221];
            assign real_msg[0][246] = recv_msg[222];
            assign real_msg[0][502] = recv_msg[223];
            assign real_msg[0][14] = recv_msg[224];
            assign real_msg[0][270] = recv_msg[225];
            assign real_msg[0][142] = recv_msg[226];
            assign real_msg[0][398] = recv_msg[227];
            assign real_msg[0][78] = recv_msg[228];
            assign real_msg[0][334] = recv_msg[229];
            assign real_msg[0][206] = recv_msg[230];
            assign real_msg[0][462] = recv_msg[231];
            assign real_msg[0][46] = recv_msg[232];
            assign real_msg[0][302] = recv_msg[233];
            assign real_msg[0][174] = recv_msg[234];
            assign real_msg[0][430] = recv_msg[235];
            assign real_msg[0][110] = recv_msg[236];
            assign real_msg[0][366] = recv_msg[237];
            assign real_msg[0][238] = recv_msg[238];
            assign real_msg[0][494] = recv_msg[239];
            assign real_msg[0][30] = recv_msg[240];
            assign real_msg[0][286] = recv_msg[241];
            assign real_msg[0][158] = recv_msg[242];
            assign real_msg[0][414] = recv_msg[243];
            assign real_msg[0][94] = recv_msg[244];
            assign real_msg[0][350] = recv_msg[245];
            assign real_msg[0][222] = recv_msg[246];
            assign real_msg[0][478] = recv_msg[247];
            assign real_msg[0][62] = recv_msg[248];
            assign real_msg[0][318] = recv_msg[249];
            assign real_msg[0][190] = recv_msg[250];
            assign real_msg[0][446] = recv_msg[251];
            assign real_msg[0][126] = recv_msg[252];
            assign real_msg[0][382] = recv_msg[253];
            assign real_msg[0][254] = recv_msg[254];
            assign real_msg[0][510] = recv_msg[255];
            assign real_msg[0][1] = recv_msg[256];
            assign real_msg[0][257] = recv_msg[257];
            assign real_msg[0][129] = recv_msg[258];
            assign real_msg[0][385] = recv_msg[259];
            assign real_msg[0][65] = recv_msg[260];
            assign real_msg[0][321] = recv_msg[261];
            assign real_msg[0][193] = recv_msg[262];
            assign real_msg[0][449] = recv_msg[263];
            assign real_msg[0][33] = recv_msg[264];
            assign real_msg[0][289] = recv_msg[265];
            assign real_msg[0][161] = recv_msg[266];
            assign real_msg[0][417] = recv_msg[267];
            assign real_msg[0][97] = recv_msg[268];
            assign real_msg[0][353] = recv_msg[269];
            assign real_msg[0][225] = recv_msg[270];
            assign real_msg[0][481] = recv_msg[271];
            assign real_msg[0][17] = recv_msg[272];
            assign real_msg[0][273] = recv_msg[273];
            assign real_msg[0][145] = recv_msg[274];
            assign real_msg[0][401] = recv_msg[275];
            assign real_msg[0][81] = recv_msg[276];
            assign real_msg[0][337] = recv_msg[277];
            assign real_msg[0][209] = recv_msg[278];
            assign real_msg[0][465] = recv_msg[279];
            assign real_msg[0][49] = recv_msg[280];
            assign real_msg[0][305] = recv_msg[281];
            assign real_msg[0][177] = recv_msg[282];
            assign real_msg[0][433] = recv_msg[283];
            assign real_msg[0][113] = recv_msg[284];
            assign real_msg[0][369] = recv_msg[285];
            assign real_msg[0][241] = recv_msg[286];
            assign real_msg[0][497] = recv_msg[287];
            assign real_msg[0][9] = recv_msg[288];
            assign real_msg[0][265] = recv_msg[289];
            assign real_msg[0][137] = recv_msg[290];
            assign real_msg[0][393] = recv_msg[291];
            assign real_msg[0][73] = recv_msg[292];
            assign real_msg[0][329] = recv_msg[293];
            assign real_msg[0][201] = recv_msg[294];
            assign real_msg[0][457] = recv_msg[295];
            assign real_msg[0][41] = recv_msg[296];
            assign real_msg[0][297] = recv_msg[297];
            assign real_msg[0][169] = recv_msg[298];
            assign real_msg[0][425] = recv_msg[299];
            assign real_msg[0][105] = recv_msg[300];
            assign real_msg[0][361] = recv_msg[301];
            assign real_msg[0][233] = recv_msg[302];
            assign real_msg[0][489] = recv_msg[303];
            assign real_msg[0][25] = recv_msg[304];
            assign real_msg[0][281] = recv_msg[305];
            assign real_msg[0][153] = recv_msg[306];
            assign real_msg[0][409] = recv_msg[307];
            assign real_msg[0][89] = recv_msg[308];
            assign real_msg[0][345] = recv_msg[309];
            assign real_msg[0][217] = recv_msg[310];
            assign real_msg[0][473] = recv_msg[311];
            assign real_msg[0][57] = recv_msg[312];
            assign real_msg[0][313] = recv_msg[313];
            assign real_msg[0][185] = recv_msg[314];
            assign real_msg[0][441] = recv_msg[315];
            assign real_msg[0][121] = recv_msg[316];
            assign real_msg[0][377] = recv_msg[317];
            assign real_msg[0][249] = recv_msg[318];
            assign real_msg[0][505] = recv_msg[319];
            assign real_msg[0][5] = recv_msg[320];
            assign real_msg[0][261] = recv_msg[321];
            assign real_msg[0][133] = recv_msg[322];
            assign real_msg[0][389] = recv_msg[323];
            assign real_msg[0][69] = recv_msg[324];
            assign real_msg[0][325] = recv_msg[325];
            assign real_msg[0][197] = recv_msg[326];
            assign real_msg[0][453] = recv_msg[327];
            assign real_msg[0][37] = recv_msg[328];
            assign real_msg[0][293] = recv_msg[329];
            assign real_msg[0][165] = recv_msg[330];
            assign real_msg[0][421] = recv_msg[331];
            assign real_msg[0][101] = recv_msg[332];
            assign real_msg[0][357] = recv_msg[333];
            assign real_msg[0][229] = recv_msg[334];
            assign real_msg[0][485] = recv_msg[335];
            assign real_msg[0][21] = recv_msg[336];
            assign real_msg[0][277] = recv_msg[337];
            assign real_msg[0][149] = recv_msg[338];
            assign real_msg[0][405] = recv_msg[339];
            assign real_msg[0][85] = recv_msg[340];
            assign real_msg[0][341] = recv_msg[341];
            assign real_msg[0][213] = recv_msg[342];
            assign real_msg[0][469] = recv_msg[343];
            assign real_msg[0][53] = recv_msg[344];
            assign real_msg[0][309] = recv_msg[345];
            assign real_msg[0][181] = recv_msg[346];
            assign real_msg[0][437] = recv_msg[347];
            assign real_msg[0][117] = recv_msg[348];
            assign real_msg[0][373] = recv_msg[349];
            assign real_msg[0][245] = recv_msg[350];
            assign real_msg[0][501] = recv_msg[351];
            assign real_msg[0][13] = recv_msg[352];
            assign real_msg[0][269] = recv_msg[353];
            assign real_msg[0][141] = recv_msg[354];
            assign real_msg[0][397] = recv_msg[355];
            assign real_msg[0][77] = recv_msg[356];
            assign real_msg[0][333] = recv_msg[357];
            assign real_msg[0][205] = recv_msg[358];
            assign real_msg[0][461] = recv_msg[359];
            assign real_msg[0][45] = recv_msg[360];
            assign real_msg[0][301] = recv_msg[361];
            assign real_msg[0][173] = recv_msg[362];
            assign real_msg[0][429] = recv_msg[363];
            assign real_msg[0][109] = recv_msg[364];
            assign real_msg[0][365] = recv_msg[365];
            assign real_msg[0][237] = recv_msg[366];
            assign real_msg[0][493] = recv_msg[367];
            assign real_msg[0][29] = recv_msg[368];
            assign real_msg[0][285] = recv_msg[369];
            assign real_msg[0][157] = recv_msg[370];
            assign real_msg[0][413] = recv_msg[371];
            assign real_msg[0][93] = recv_msg[372];
            assign real_msg[0][349] = recv_msg[373];
            assign real_msg[0][221] = recv_msg[374];
            assign real_msg[0][477] = recv_msg[375];
            assign real_msg[0][61] = recv_msg[376];
            assign real_msg[0][317] = recv_msg[377];
            assign real_msg[0][189] = recv_msg[378];
            assign real_msg[0][445] = recv_msg[379];
            assign real_msg[0][125] = recv_msg[380];
            assign real_msg[0][381] = recv_msg[381];
            assign real_msg[0][253] = recv_msg[382];
            assign real_msg[0][509] = recv_msg[383];
            assign real_msg[0][3] = recv_msg[384];
            assign real_msg[0][259] = recv_msg[385];
            assign real_msg[0][131] = recv_msg[386];
            assign real_msg[0][387] = recv_msg[387];
            assign real_msg[0][67] = recv_msg[388];
            assign real_msg[0][323] = recv_msg[389];
            assign real_msg[0][195] = recv_msg[390];
            assign real_msg[0][451] = recv_msg[391];
            assign real_msg[0][35] = recv_msg[392];
            assign real_msg[0][291] = recv_msg[393];
            assign real_msg[0][163] = recv_msg[394];
            assign real_msg[0][419] = recv_msg[395];
            assign real_msg[0][99] = recv_msg[396];
            assign real_msg[0][355] = recv_msg[397];
            assign real_msg[0][227] = recv_msg[398];
            assign real_msg[0][483] = recv_msg[399];
            assign real_msg[0][19] = recv_msg[400];
            assign real_msg[0][275] = recv_msg[401];
            assign real_msg[0][147] = recv_msg[402];
            assign real_msg[0][403] = recv_msg[403];
            assign real_msg[0][83] = recv_msg[404];
            assign real_msg[0][339] = recv_msg[405];
            assign real_msg[0][211] = recv_msg[406];
            assign real_msg[0][467] = recv_msg[407];
            assign real_msg[0][51] = recv_msg[408];
            assign real_msg[0][307] = recv_msg[409];
            assign real_msg[0][179] = recv_msg[410];
            assign real_msg[0][435] = recv_msg[411];
            assign real_msg[0][115] = recv_msg[412];
            assign real_msg[0][371] = recv_msg[413];
            assign real_msg[0][243] = recv_msg[414];
            assign real_msg[0][499] = recv_msg[415];
            assign real_msg[0][11] = recv_msg[416];
            assign real_msg[0][267] = recv_msg[417];
            assign real_msg[0][139] = recv_msg[418];
            assign real_msg[0][395] = recv_msg[419];
            assign real_msg[0][75] = recv_msg[420];
            assign real_msg[0][331] = recv_msg[421];
            assign real_msg[0][203] = recv_msg[422];
            assign real_msg[0][459] = recv_msg[423];
            assign real_msg[0][43] = recv_msg[424];
            assign real_msg[0][299] = recv_msg[425];
            assign real_msg[0][171] = recv_msg[426];
            assign real_msg[0][427] = recv_msg[427];
            assign real_msg[0][107] = recv_msg[428];
            assign real_msg[0][363] = recv_msg[429];
            assign real_msg[0][235] = recv_msg[430];
            assign real_msg[0][491] = recv_msg[431];
            assign real_msg[0][27] = recv_msg[432];
            assign real_msg[0][283] = recv_msg[433];
            assign real_msg[0][155] = recv_msg[434];
            assign real_msg[0][411] = recv_msg[435];
            assign real_msg[0][91] = recv_msg[436];
            assign real_msg[0][347] = recv_msg[437];
            assign real_msg[0][219] = recv_msg[438];
            assign real_msg[0][475] = recv_msg[439];
            assign real_msg[0][59] = recv_msg[440];
            assign real_msg[0][315] = recv_msg[441];
            assign real_msg[0][187] = recv_msg[442];
            assign real_msg[0][443] = recv_msg[443];
            assign real_msg[0][123] = recv_msg[444];
            assign real_msg[0][379] = recv_msg[445];
            assign real_msg[0][251] = recv_msg[446];
            assign real_msg[0][507] = recv_msg[447];
            assign real_msg[0][7] = recv_msg[448];
            assign real_msg[0][263] = recv_msg[449];
            assign real_msg[0][135] = recv_msg[450];
            assign real_msg[0][391] = recv_msg[451];
            assign real_msg[0][71] = recv_msg[452];
            assign real_msg[0][327] = recv_msg[453];
            assign real_msg[0][199] = recv_msg[454];
            assign real_msg[0][455] = recv_msg[455];
            assign real_msg[0][39] = recv_msg[456];
            assign real_msg[0][295] = recv_msg[457];
            assign real_msg[0][167] = recv_msg[458];
            assign real_msg[0][423] = recv_msg[459];
            assign real_msg[0][103] = recv_msg[460];
            assign real_msg[0][359] = recv_msg[461];
            assign real_msg[0][231] = recv_msg[462];
            assign real_msg[0][487] = recv_msg[463];
            assign real_msg[0][23] = recv_msg[464];
            assign real_msg[0][279] = recv_msg[465];
            assign real_msg[0][151] = recv_msg[466];
            assign real_msg[0][407] = recv_msg[467];
            assign real_msg[0][87] = recv_msg[468];
            assign real_msg[0][343] = recv_msg[469];
            assign real_msg[0][215] = recv_msg[470];
            assign real_msg[0][471] = recv_msg[471];
            assign real_msg[0][55] = recv_msg[472];
            assign real_msg[0][311] = recv_msg[473];
            assign real_msg[0][183] = recv_msg[474];
            assign real_msg[0][439] = recv_msg[475];
            assign real_msg[0][119] = recv_msg[476];
            assign real_msg[0][375] = recv_msg[477];
            assign real_msg[0][247] = recv_msg[478];
            assign real_msg[0][503] = recv_msg[479];
            assign real_msg[0][15] = recv_msg[480];
            assign real_msg[0][271] = recv_msg[481];
            assign real_msg[0][143] = recv_msg[482];
            assign real_msg[0][399] = recv_msg[483];
            assign real_msg[0][79] = recv_msg[484];
            assign real_msg[0][335] = recv_msg[485];
            assign real_msg[0][207] = recv_msg[486];
            assign real_msg[0][463] = recv_msg[487];
            assign real_msg[0][47] = recv_msg[488];
            assign real_msg[0][303] = recv_msg[489];
            assign real_msg[0][175] = recv_msg[490];
            assign real_msg[0][431] = recv_msg[491];
            assign real_msg[0][111] = recv_msg[492];
            assign real_msg[0][367] = recv_msg[493];
            assign real_msg[0][239] = recv_msg[494];
            assign real_msg[0][495] = recv_msg[495];
            assign real_msg[0][31] = recv_msg[496];
            assign real_msg[0][287] = recv_msg[497];
            assign real_msg[0][159] = recv_msg[498];
            assign real_msg[0][415] = recv_msg[499];
            assign real_msg[0][95] = recv_msg[500];
            assign real_msg[0][351] = recv_msg[501];
            assign real_msg[0][223] = recv_msg[502];
            assign real_msg[0][479] = recv_msg[503];
            assign real_msg[0][63] = recv_msg[504];
            assign real_msg[0][319] = recv_msg[505];
            assign real_msg[0][191] = recv_msg[506];
            assign real_msg[0][447] = recv_msg[507];
            assign real_msg[0][127] = recv_msg[508];
            assign real_msg[0][383] = recv_msg[509];
            assign real_msg[0][255] = recv_msg[510];
            assign real_msg[0][511] = recv_msg[511];
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_512VRTL SineWave (.sine_wave_out(sine_wave_out));
        end else if(N_SAMPLES == 256) begin
           assign real_msg[0][0] = recv_msg[0];
            assign real_msg[0][128] = recv_msg[1];
            assign real_msg[0][64] = recv_msg[2];
            assign real_msg[0][192] = recv_msg[3];
            assign real_msg[0][32] = recv_msg[4];
            assign real_msg[0][160] = recv_msg[5];
            assign real_msg[0][96] = recv_msg[6];
            assign real_msg[0][224] = recv_msg[7];
            assign real_msg[0][16] = recv_msg[8];
            assign real_msg[0][144] = recv_msg[9];
            assign real_msg[0][80] = recv_msg[10];
            assign real_msg[0][208] = recv_msg[11];
            assign real_msg[0][48] = recv_msg[12];
            assign real_msg[0][176] = recv_msg[13];
            assign real_msg[0][112] = recv_msg[14];
            assign real_msg[0][240] = recv_msg[15];
            assign real_msg[0][8] = recv_msg[16];
            assign real_msg[0][136] = recv_msg[17];
            assign real_msg[0][72] = recv_msg[18];
            assign real_msg[0][200] = recv_msg[19];
            assign real_msg[0][40] = recv_msg[20];
            assign real_msg[0][168] = recv_msg[21];
            assign real_msg[0][104] = recv_msg[22];
            assign real_msg[0][232] = recv_msg[23];
            assign real_msg[0][24] = recv_msg[24];
            assign real_msg[0][152] = recv_msg[25];
            assign real_msg[0][88] = recv_msg[26];
            assign real_msg[0][216] = recv_msg[27];
            assign real_msg[0][56] = recv_msg[28];
            assign real_msg[0][184] = recv_msg[29];
            assign real_msg[0][120] = recv_msg[30];
            assign real_msg[0][248] = recv_msg[31];
            assign real_msg[0][4] = recv_msg[32];
            assign real_msg[0][132] = recv_msg[33];
            assign real_msg[0][68] = recv_msg[34];
            assign real_msg[0][196] = recv_msg[35];
            assign real_msg[0][36] = recv_msg[36];
            assign real_msg[0][164] = recv_msg[37];
            assign real_msg[0][100] = recv_msg[38];
            assign real_msg[0][228] = recv_msg[39];
            assign real_msg[0][20] = recv_msg[40];
            assign real_msg[0][148] = recv_msg[41];
            assign real_msg[0][84] = recv_msg[42];
            assign real_msg[0][212] = recv_msg[43];
            assign real_msg[0][52] = recv_msg[44];
            assign real_msg[0][180] = recv_msg[45];
            assign real_msg[0][116] = recv_msg[46];
            assign real_msg[0][244] = recv_msg[47];
            assign real_msg[0][12] = recv_msg[48];
            assign real_msg[0][140] = recv_msg[49];
            assign real_msg[0][76] = recv_msg[50];
            assign real_msg[0][204] = recv_msg[51];
            assign real_msg[0][44] = recv_msg[52];
            assign real_msg[0][172] = recv_msg[53];
            assign real_msg[0][108] = recv_msg[54];
            assign real_msg[0][236] = recv_msg[55];
            assign real_msg[0][28] = recv_msg[56];
            assign real_msg[0][156] = recv_msg[57];
            assign real_msg[0][92] = recv_msg[58];
            assign real_msg[0][220] = recv_msg[59];
            assign real_msg[0][60] = recv_msg[60];
            assign real_msg[0][188] = recv_msg[61];
            assign real_msg[0][124] = recv_msg[62];
            assign real_msg[0][252] = recv_msg[63];
            assign real_msg[0][2] = recv_msg[64];
            assign real_msg[0][130] = recv_msg[65];
            assign real_msg[0][66] = recv_msg[66];
            assign real_msg[0][194] = recv_msg[67];
            assign real_msg[0][34] = recv_msg[68];
            assign real_msg[0][162] = recv_msg[69];
            assign real_msg[0][98] = recv_msg[70];
            assign real_msg[0][226] = recv_msg[71];
            assign real_msg[0][18] = recv_msg[72];
            assign real_msg[0][146] = recv_msg[73];
            assign real_msg[0][82] = recv_msg[74];
            assign real_msg[0][210] = recv_msg[75];
            assign real_msg[0][50] = recv_msg[76];
            assign real_msg[0][178] = recv_msg[77];
            assign real_msg[0][114] = recv_msg[78];
            assign real_msg[0][242] = recv_msg[79];
            assign real_msg[0][10] = recv_msg[80];
            assign real_msg[0][138] = recv_msg[81];
            assign real_msg[0][74] = recv_msg[82];
            assign real_msg[0][202] = recv_msg[83];
            assign real_msg[0][42] = recv_msg[84];
            assign real_msg[0][170] = recv_msg[85];
            assign real_msg[0][106] = recv_msg[86];
            assign real_msg[0][234] = recv_msg[87];
            assign real_msg[0][26] = recv_msg[88];
            assign real_msg[0][154] = recv_msg[89];
            assign real_msg[0][90] = recv_msg[90];
            assign real_msg[0][218] = recv_msg[91];
            assign real_msg[0][58] = recv_msg[92];
            assign real_msg[0][186] = recv_msg[93];
            assign real_msg[0][122] = recv_msg[94];
            assign real_msg[0][250] = recv_msg[95];
            assign real_msg[0][6] = recv_msg[96];
            assign real_msg[0][134] = recv_msg[97];
            assign real_msg[0][70] = recv_msg[98];
            assign real_msg[0][198] = recv_msg[99];
            assign real_msg[0][38] = recv_msg[100];
            assign real_msg[0][166] = recv_msg[101];
            assign real_msg[0][102] = recv_msg[102];
            assign real_msg[0][230] = recv_msg[103];
            assign real_msg[0][22] = recv_msg[104];
            assign real_msg[0][150] = recv_msg[105];
            assign real_msg[0][86] = recv_msg[106];
            assign real_msg[0][214] = recv_msg[107];
            assign real_msg[0][54] = recv_msg[108];
            assign real_msg[0][182] = recv_msg[109];
            assign real_msg[0][118] = recv_msg[110];
            assign real_msg[0][246] = recv_msg[111];
            assign real_msg[0][14] = recv_msg[112];
            assign real_msg[0][142] = recv_msg[113];
            assign real_msg[0][78] = recv_msg[114];
            assign real_msg[0][206] = recv_msg[115];
            assign real_msg[0][46] = recv_msg[116];
            assign real_msg[0][174] = recv_msg[117];
            assign real_msg[0][110] = recv_msg[118];
            assign real_msg[0][238] = recv_msg[119];
            assign real_msg[0][30] = recv_msg[120];
            assign real_msg[0][158] = recv_msg[121];
            assign real_msg[0][94] = recv_msg[122];
            assign real_msg[0][222] = recv_msg[123];
            assign real_msg[0][62] = recv_msg[124];
            assign real_msg[0][190] = recv_msg[125];
            assign real_msg[0][126] = recv_msg[126];
            assign real_msg[0][254] = recv_msg[127];
            assign real_msg[0][1] = recv_msg[128];
            assign real_msg[0][129] = recv_msg[129];
            assign real_msg[0][65] = recv_msg[130];
            assign real_msg[0][193] = recv_msg[131];
            assign real_msg[0][33] = recv_msg[132];
            assign real_msg[0][161] = recv_msg[133];
            assign real_msg[0][97] = recv_msg[134];
            assign real_msg[0][225] = recv_msg[135];
            assign real_msg[0][17] = recv_msg[136];
            assign real_msg[0][145] = recv_msg[137];
            assign real_msg[0][81] = recv_msg[138];
            assign real_msg[0][209] = recv_msg[139];
            assign real_msg[0][49] = recv_msg[140];
            assign real_msg[0][177] = recv_msg[141];
            assign real_msg[0][113] = recv_msg[142];
            assign real_msg[0][241] = recv_msg[143];
            assign real_msg[0][9] = recv_msg[144];
            assign real_msg[0][137] = recv_msg[145];
            assign real_msg[0][73] = recv_msg[146];
            assign real_msg[0][201] = recv_msg[147];
            assign real_msg[0][41] = recv_msg[148];
            assign real_msg[0][169] = recv_msg[149];
            assign real_msg[0][105] = recv_msg[150];
            assign real_msg[0][233] = recv_msg[151];
            assign real_msg[0][25] = recv_msg[152];
            assign real_msg[0][153] = recv_msg[153];
            assign real_msg[0][89] = recv_msg[154];
            assign real_msg[0][217] = recv_msg[155];
            assign real_msg[0][57] = recv_msg[156];
            assign real_msg[0][185] = recv_msg[157];
            assign real_msg[0][121] = recv_msg[158];
            assign real_msg[0][249] = recv_msg[159];
            assign real_msg[0][5] = recv_msg[160];
            assign real_msg[0][133] = recv_msg[161];
            assign real_msg[0][69] = recv_msg[162];
            assign real_msg[0][197] = recv_msg[163];
            assign real_msg[0][37] = recv_msg[164];
            assign real_msg[0][165] = recv_msg[165];
            assign real_msg[0][101] = recv_msg[166];
            assign real_msg[0][229] = recv_msg[167];
            assign real_msg[0][21] = recv_msg[168];
            assign real_msg[0][149] = recv_msg[169];
            assign real_msg[0][85] = recv_msg[170];
            assign real_msg[0][213] = recv_msg[171];
            assign real_msg[0][53] = recv_msg[172];
            assign real_msg[0][181] = recv_msg[173];
            assign real_msg[0][117] = recv_msg[174];
            assign real_msg[0][245] = recv_msg[175];
            assign real_msg[0][13] = recv_msg[176];
            assign real_msg[0][141] = recv_msg[177];
            assign real_msg[0][77] = recv_msg[178];
            assign real_msg[0][205] = recv_msg[179];
            assign real_msg[0][45] = recv_msg[180];
            assign real_msg[0][173] = recv_msg[181];
            assign real_msg[0][109] = recv_msg[182];
            assign real_msg[0][237] = recv_msg[183];
            assign real_msg[0][29] = recv_msg[184];
            assign real_msg[0][157] = recv_msg[185];
            assign real_msg[0][93] = recv_msg[186];
            assign real_msg[0][221] = recv_msg[187];
            assign real_msg[0][61] = recv_msg[188];
            assign real_msg[0][189] = recv_msg[189];
            assign real_msg[0][125] = recv_msg[190];
            assign real_msg[0][253] = recv_msg[191];
            assign real_msg[0][3] = recv_msg[192];
            assign real_msg[0][131] = recv_msg[193];
            assign real_msg[0][67] = recv_msg[194];
            assign real_msg[0][195] = recv_msg[195];
            assign real_msg[0][35] = recv_msg[196];
            assign real_msg[0][163] = recv_msg[197];
            assign real_msg[0][99] = recv_msg[198];
            assign real_msg[0][227] = recv_msg[199];
            assign real_msg[0][19] = recv_msg[200];
            assign real_msg[0][147] = recv_msg[201];
            assign real_msg[0][83] = recv_msg[202];
            assign real_msg[0][211] = recv_msg[203];
            assign real_msg[0][51] = recv_msg[204];
            assign real_msg[0][179] = recv_msg[205];
            assign real_msg[0][115] = recv_msg[206];
            assign real_msg[0][243] = recv_msg[207];
            assign real_msg[0][11] = recv_msg[208];
            assign real_msg[0][139] = recv_msg[209];
            assign real_msg[0][75] = recv_msg[210];
            assign real_msg[0][203] = recv_msg[211];
            assign real_msg[0][43] = recv_msg[212];
            assign real_msg[0][171] = recv_msg[213];
            assign real_msg[0][107] = recv_msg[214];
            assign real_msg[0][235] = recv_msg[215];
            assign real_msg[0][27] = recv_msg[216];
            assign real_msg[0][155] = recv_msg[217];
            assign real_msg[0][91] = recv_msg[218];
            assign real_msg[0][219] = recv_msg[219];
            assign real_msg[0][59] = recv_msg[220];
            assign real_msg[0][187] = recv_msg[221];
            assign real_msg[0][123] = recv_msg[222];
            assign real_msg[0][251] = recv_msg[223];
            assign real_msg[0][7] = recv_msg[224];
            assign real_msg[0][135] = recv_msg[225];
            assign real_msg[0][71] = recv_msg[226];
            assign real_msg[0][199] = recv_msg[227];
            assign real_msg[0][39] = recv_msg[228];
            assign real_msg[0][167] = recv_msg[229];
            assign real_msg[0][103] = recv_msg[230];
            assign real_msg[0][231] = recv_msg[231];
            assign real_msg[0][23] = recv_msg[232];
            assign real_msg[0][151] = recv_msg[233];
            assign real_msg[0][87] = recv_msg[234];
            assign real_msg[0][215] = recv_msg[235];
            assign real_msg[0][55] = recv_msg[236];
            assign real_msg[0][183] = recv_msg[237];
            assign real_msg[0][119] = recv_msg[238];
            assign real_msg[0][247] = recv_msg[239];
            assign real_msg[0][15] = recv_msg[240];
            assign real_msg[0][143] = recv_msg[241];
            assign real_msg[0][79] = recv_msg[242];
            assign real_msg[0][207] = recv_msg[243];
            assign real_msg[0][47] = recv_msg[244];
            assign real_msg[0][175] = recv_msg[245];
            assign real_msg[0][111] = recv_msg[246];
            assign real_msg[0][239] = recv_msg[247];
            assign real_msg[0][31] = recv_msg[248];
            assign real_msg[0][159] = recv_msg[249];
            assign real_msg[0][95] = recv_msg[250];
            assign real_msg[0][223] = recv_msg[251];
            assign real_msg[0][63] = recv_msg[252];
            assign real_msg[0][191] = recv_msg[253];
            assign real_msg[0][127] = recv_msg[254];
            assign real_msg[0][255] = recv_msg[255];
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_256VRTL SineWave (.sine_wave_out(sine_wave_out));
        
        end else if(N_SAMPLES == 128) begin
            assign real_msg[0][0] = recv_msg[0];
            assign real_msg[0][64] = recv_msg[1];
            assign real_msg[0][32] = recv_msg[2];
            assign real_msg[0][96] = recv_msg[3];
            assign real_msg[0][16] = recv_msg[4];
            assign real_msg[0][80] = recv_msg[5];
            assign real_msg[0][48] = recv_msg[6];
            assign real_msg[0][112] = recv_msg[7];
            assign real_msg[0][8] = recv_msg[8];
            assign real_msg[0][72] = recv_msg[9];
            assign real_msg[0][40] = recv_msg[10];
            assign real_msg[0][104] = recv_msg[11];
            assign real_msg[0][24] = recv_msg[12];
            assign real_msg[0][88] = recv_msg[13];
            assign real_msg[0][56] = recv_msg[14];
            assign real_msg[0][120] = recv_msg[15];
            assign real_msg[0][4] = recv_msg[16];
            assign real_msg[0][68] = recv_msg[17];
            assign real_msg[0][36] = recv_msg[18];
            assign real_msg[0][100] = recv_msg[19];
            assign real_msg[0][20] = recv_msg[20];
            assign real_msg[0][84] = recv_msg[21];
            assign real_msg[0][52] = recv_msg[22];
            assign real_msg[0][116] = recv_msg[23];
            assign real_msg[0][12] = recv_msg[24];
            assign real_msg[0][76] = recv_msg[25];
            assign real_msg[0][44] = recv_msg[26];
            assign real_msg[0][108] = recv_msg[27];
            assign real_msg[0][28] = recv_msg[28];
            assign real_msg[0][92] = recv_msg[29];
            assign real_msg[0][60] = recv_msg[30];
            assign real_msg[0][124] = recv_msg[31];
            assign real_msg[0][2] = recv_msg[32];
            assign real_msg[0][66] = recv_msg[33];
            assign real_msg[0][34] = recv_msg[34];
            assign real_msg[0][98] = recv_msg[35];
            assign real_msg[0][18] = recv_msg[36];
            assign real_msg[0][82] = recv_msg[37];
            assign real_msg[0][50] = recv_msg[38];
            assign real_msg[0][114] = recv_msg[39];
            assign real_msg[0][10] = recv_msg[40];
            assign real_msg[0][74] = recv_msg[41];
            assign real_msg[0][42] = recv_msg[42];
            assign real_msg[0][106] = recv_msg[43];
            assign real_msg[0][26] = recv_msg[44];
            assign real_msg[0][90] = recv_msg[45];
            assign real_msg[0][58] = recv_msg[46];
            assign real_msg[0][122] = recv_msg[47];
            assign real_msg[0][6] = recv_msg[48];
            assign real_msg[0][70] = recv_msg[49];
            assign real_msg[0][38] = recv_msg[50];
            assign real_msg[0][102] = recv_msg[51];
            assign real_msg[0][22] = recv_msg[52];
            assign real_msg[0][86] = recv_msg[53];
            assign real_msg[0][54] = recv_msg[54];
            assign real_msg[0][118] = recv_msg[55];
            assign real_msg[0][14] = recv_msg[56];
            assign real_msg[0][78] = recv_msg[57];
            assign real_msg[0][46] = recv_msg[58];
            assign real_msg[0][110] = recv_msg[59];
            assign real_msg[0][30] = recv_msg[60];
            assign real_msg[0][94] = recv_msg[61];
            assign real_msg[0][62] = recv_msg[62];
            assign real_msg[0][126] = recv_msg[63];
            assign real_msg[0][1] = recv_msg[64];
            assign real_msg[0][65] = recv_msg[65];
            assign real_msg[0][33] = recv_msg[66];
            assign real_msg[0][97] = recv_msg[67];
            assign real_msg[0][17] = recv_msg[68];
            assign real_msg[0][81] = recv_msg[69];
            assign real_msg[0][49] = recv_msg[70];
            assign real_msg[0][113] = recv_msg[71];
            assign real_msg[0][9] = recv_msg[72];
            assign real_msg[0][73] = recv_msg[73];
            assign real_msg[0][41] = recv_msg[74];
            assign real_msg[0][105] = recv_msg[75];
            assign real_msg[0][25] = recv_msg[76];
            assign real_msg[0][89] = recv_msg[77];
            assign real_msg[0][57] = recv_msg[78];
            assign real_msg[0][121] = recv_msg[79];
            assign real_msg[0][5] = recv_msg[80];
            assign real_msg[0][69] = recv_msg[81];
            assign real_msg[0][37] = recv_msg[82];
            assign real_msg[0][101] = recv_msg[83];
            assign real_msg[0][21] = recv_msg[84];
            assign real_msg[0][85] = recv_msg[85];
            assign real_msg[0][53] = recv_msg[86];
            assign real_msg[0][117] = recv_msg[87];
            assign real_msg[0][13] = recv_msg[88];
            assign real_msg[0][77] = recv_msg[89];
            assign real_msg[0][45] = recv_msg[90];
            assign real_msg[0][109] = recv_msg[91];
            assign real_msg[0][29] = recv_msg[92];
            assign real_msg[0][93] = recv_msg[93];
            assign real_msg[0][61] = recv_msg[94];
            assign real_msg[0][125] = recv_msg[95];
            assign real_msg[0][3] = recv_msg[96];
            assign real_msg[0][67] = recv_msg[97];
            assign real_msg[0][35] = recv_msg[98];
            assign real_msg[0][99] = recv_msg[99];
            assign real_msg[0][19] = recv_msg[100];
            assign real_msg[0][83] = recv_msg[101];
            assign real_msg[0][51] = recv_msg[102];
            assign real_msg[0][115] = recv_msg[103];
            assign real_msg[0][11] = recv_msg[104];
            assign real_msg[0][75] = recv_msg[105];
            assign real_msg[0][43] = recv_msg[106];
            assign real_msg[0][107] = recv_msg[107];
            assign real_msg[0][27] = recv_msg[108];
            assign real_msg[0][91] = recv_msg[109];
            assign real_msg[0][59] = recv_msg[110];
            assign real_msg[0][123] = recv_msg[111];
            assign real_msg[0][7] = recv_msg[112];
            assign real_msg[0][71] = recv_msg[113];
            assign real_msg[0][39] = recv_msg[114];
            assign real_msg[0][103] = recv_msg[115];
            assign real_msg[0][23] = recv_msg[116];
            assign real_msg[0][87] = recv_msg[117];
            assign real_msg[0][55] = recv_msg[118];
            assign real_msg[0][119] = recv_msg[119];
            assign real_msg[0][15] = recv_msg[120];
            assign real_msg[0][79] = recv_msg[121];
            assign real_msg[0][47] = recv_msg[122];
            assign real_msg[0][111] = recv_msg[123];
            assign real_msg[0][31] = recv_msg[124];
            assign real_msg[0][95] = recv_msg[125];
            assign real_msg[0][63] = recv_msg[126];
            assign real_msg[0][127] = recv_msg[127];
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_128VRTL SineWave (.sine_wave_out(sine_wave_out));
        end else if(N_SAMPLES == 64) begin
            assign real_msg[0][0] = recv_msg[0];
            assign real_msg[0][32] = recv_msg[1];
            assign real_msg[0][16] = recv_msg[2];
            assign real_msg[0][48] = recv_msg[3];
            assign real_msg[0][8] = recv_msg[4];
            assign real_msg[0][40] = recv_msg[5];
            assign real_msg[0][24] = recv_msg[6];
            assign real_msg[0][56] = recv_msg[7];
            assign real_msg[0][4] = recv_msg[8];
            assign real_msg[0][36] = recv_msg[9];
            assign real_msg[0][20] = recv_msg[10];
            assign real_msg[0][52] = recv_msg[11];
            assign real_msg[0][12] = recv_msg[12];
            assign real_msg[0][44] = recv_msg[13];
            assign real_msg[0][28] = recv_msg[14];
            assign real_msg[0][60] = recv_msg[15];
            assign real_msg[0][2] = recv_msg[16];
            assign real_msg[0][34] = recv_msg[17];
            assign real_msg[0][18] = recv_msg[18];
            assign real_msg[0][50] = recv_msg[19];
            assign real_msg[0][10] = recv_msg[20];
            assign real_msg[0][42] = recv_msg[21];
            assign real_msg[0][26] = recv_msg[22];
            assign real_msg[0][58] = recv_msg[23];
            assign real_msg[0][6] = recv_msg[24];
            assign real_msg[0][38] = recv_msg[25];
            assign real_msg[0][22] = recv_msg[26];
            assign real_msg[0][54] = recv_msg[27];
            assign real_msg[0][14] = recv_msg[28];
            assign real_msg[0][46] = recv_msg[29];
            assign real_msg[0][30] = recv_msg[30];
            assign real_msg[0][62] = recv_msg[31];
            assign real_msg[0][1] = recv_msg[32];
            assign real_msg[0][33] = recv_msg[33];
            assign real_msg[0][17] = recv_msg[34];
            assign real_msg[0][49] = recv_msg[35];
            assign real_msg[0][9] = recv_msg[36];
            assign real_msg[0][41] = recv_msg[37];
            assign real_msg[0][25] = recv_msg[38];
            assign real_msg[0][57] = recv_msg[39];
            assign real_msg[0][5] = recv_msg[40];
            assign real_msg[0][37] = recv_msg[41];
            assign real_msg[0][21] = recv_msg[42];
            assign real_msg[0][53] = recv_msg[43];
            assign real_msg[0][13] = recv_msg[44];
            assign real_msg[0][45] = recv_msg[45];
            assign real_msg[0][29] = recv_msg[46];
            assign real_msg[0][61] = recv_msg[47];
            assign real_msg[0][3] = recv_msg[48];
            assign real_msg[0][35] = recv_msg[49];
            assign real_msg[0][19] = recv_msg[50];
            assign real_msg[0][51] = recv_msg[51];
            assign real_msg[0][11] = recv_msg[52];
            assign real_msg[0][43] = recv_msg[53];
            assign real_msg[0][27] = recv_msg[54];
            assign real_msg[0][59] = recv_msg[55];
            assign real_msg[0][7] = recv_msg[56];
            assign real_msg[0][39] = recv_msg[57];
            assign real_msg[0][23] = recv_msg[58];
            assign real_msg[0][55] = recv_msg[59];
            assign real_msg[0][15] = recv_msg[60];
            assign real_msg[0][47] = recv_msg[61];
            assign real_msg[0][31] = recv_msg[62];
            assign real_msg[0][63] = recv_msg[63];
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_64VRTL SineWave (.sine_wave_out(sine_wave_out));

        end else if(N_SAMPLES == 32) begin
            assign real_msg[0][0] = recv_msg[0];
            assign real_msg[0][16] = recv_msg[1];
            assign real_msg[0][8] = recv_msg[2];
            assign real_msg[0][24] = recv_msg[3];
            assign real_msg[0][4] = recv_msg[4];
            assign real_msg[0][20] = recv_msg[5];
            assign real_msg[0][12] = recv_msg[6];
            assign real_msg[0][28] = recv_msg[7];
            assign real_msg[0][2] = recv_msg[8];
            assign real_msg[0][18] = recv_msg[9];
            assign real_msg[0][10] = recv_msg[10];
            assign real_msg[0][26] = recv_msg[11];
            assign real_msg[0][6] = recv_msg[12];
            assign real_msg[0][22] = recv_msg[13];
            assign real_msg[0][14] = recv_msg[14];
            assign real_msg[0][30] = recv_msg[15];
            assign real_msg[0][1] = recv_msg[16];
            assign real_msg[0][17] = recv_msg[17];
            assign real_msg[0][9] = recv_msg[18];
            assign real_msg[0][25] = recv_msg[19];
            assign real_msg[0][5] = recv_msg[20];
            assign real_msg[0][21] = recv_msg[21];
            assign real_msg[0][13] = recv_msg[22];
            assign real_msg[0][29] = recv_msg[23];
            assign real_msg[0][3] = recv_msg[24];
            assign real_msg[0][19] = recv_msg[25];
            assign real_msg[0][11] = recv_msg[26];
            assign real_msg[0][27] = recv_msg[27];
            assign real_msg[0][7] = recv_msg[28];
            assign real_msg[0][23] = recv_msg[29];
            assign real_msg[0][15] = recv_msg[30];
            assign real_msg[0][31] = recv_msg[31];
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_32VRTL SineWave (.sine_wave_out(sine_wave_out));



        end else if(N_SAMPLES == 16) begin
            assign real_msg[0][0] = recv_msg[0];
            assign real_msg[0][8] = recv_msg[1];
            assign real_msg[0][4] = recv_msg[2];
            assign real_msg[0][12] = recv_msg[3];
            assign real_msg[0][2] = recv_msg[4];
            assign real_msg[0][10] = recv_msg[5];
            assign real_msg[0][6] = recv_msg[6];
            assign real_msg[0][14] = recv_msg[7];
            assign real_msg[0][1] = recv_msg[8];
            assign real_msg[0][9] = recv_msg[9];
            assign real_msg[0][5] = recv_msg[10];
            assign real_msg[0][13] = recv_msg[11];
            assign real_msg[0][3] = recv_msg[12];
            assign real_msg[0][11] = recv_msg[13];
            assign real_msg[0][7] = recv_msg[14];
            assign real_msg[0][15] = recv_msg[15];
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_16VRTL SineWave (.sine_wave_out(sine_wave_out));
        end else if(N_SAMPLES == 8) begin
            assign real_msg[0][0] = recv_msg[0];
            assign real_msg[0][4] = recv_msg[1];
            assign real_msg[0][2] = recv_msg[2];
            assign real_msg[0][6] = recv_msg[3];
            assign real_msg[0][1] = recv_msg[4];
            assign real_msg[0][5] = recv_msg[5];
            assign real_msg[0][3] = recv_msg[6];
            assign real_msg[0][7] = recv_msg[7];
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_8VRTL SineWave (.sine_wave_out(sine_wave_out));
        end else if(N_SAMPLES == 4) begin
            assign real_msg[0][0] = recv_msg[0];
            assign real_msg[0][2] = recv_msg[1];
            assign real_msg[0][1] = recv_msg[2];
            assign real_msg[0][3] = recv_msg[3];
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_4VRTL SineWave (.sine_wave_out(sine_wave_out));
        end else if(N_SAMPLES == 2) begin
            assign real_msg[0][0] = recv_msg[0];
            assign real_msg[0][1] = recv_msg[1];
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_2VRTL SineWave (.sine_wave_out(sine_wave_out));
        end
    endgenerate

    
    
    generate
        genvar i;
        genvar b;
        for( i = 0; i < $clog2(N_SAMPLES); i++ ) begin
            FFT_StageVRTL #(.BIT_WIDTH(BIT_WIDTH), .DECIMAL_PT(DECIMAL_PT), .N_SAMPLES(N_SAMPLES), .STAGE_FFT(i)) fft_stage ( 
                .recv_msg_real(real_msg   [i]),
                .recv_msg_imag(complex_msg[i]),
                .recv_val     (val_in     [i]),
                .recv_rdy     (rdy_in     [i]),
        
                .send_msg_real(real_msg   [i + 1]),
                .send_msg_imag(complex_msg[i + 1]),
                .send_val     (val_in     [i + 1]),
                .send_rdy     (rdy_in     [i + 1]),

                .sine_wave_out(sine_wave_out),

                .reset        (reset),
                .clk          (clk)
                );
        end
    endgenerate

    always @(*) begin
        int i;
        for(i = 0; i < N_SAMPLES; i++) begin

            send_msg[i] = real_msg[$clog2(N_SAMPLES)][i];

        end
    end
    

endmodule

`endif
`line 6 "../../../tape_in_sim/sim/minion_FFT/FFTSPIMinionVRTL.v" 0
`line 1 "../../../C2S2-SERDES/sim/serializer/SerializerVRTL.v" 0


`line 1 "../../../C2S2-SERDES/sim/serializer/RegisterV_Reset.v" 0
`ifndef PROJECT_REGISTER_V_RESET
`define PROJECT_REGISTER_V_RESET

module RegisterV_Reset
	#(parameter N = 8)
	(clk, reset, w, d, q);
    input logic clk;
    input logic reset;
    input  logic w;
    input logic [N-1:0] d;
    output logic [N-1:0] q;
    logic [N-1:0] regout;

    assign q = regout;

    always @(posedge clk) begin
	if (reset)
	    regout <= 0;
	else if (w)
	    regout <= d;
    else regout <= regout;
        
    end
endmodule

`endif

`line 4 "../../../C2S2-SERDES/sim/serializer/SerializerVRTL.v" 0

module SerializerVRTL
   #(
        BIT_WIDTH  = 32,
        N_SAMPLES  = 8
    )
    (
        input  logic [BIT_WIDTH - 1:0] recv_msg [N_SAMPLES - 1:0],
        input  logic                   recv_val                  ,
        output logic                   recv_rdy                  ,

        output logic [BIT_WIDTH - 1:0] send_msg,
        output logic                   send_val                  ,
        input  logic                   send_rdy                  ,

        input  logic                   reset                     ,
        input  logic                   clk
    );

    logic [$clog2(N_SAMPLES) - 1:0] mux_sel;
    
    logic reg_en;

    logic [BIT_WIDTH - 1:0] reg_out [N_SAMPLES - 1:0];
    
    generate
        genvar i;
        for( i = 0; i < N_SAMPLES; i++) begin
            RegisterV_Reset #( .N(BIT_WIDTH) ) register ( .clk(clk), .reset(reset), .w(reg_en), .d(recv_msg[i]), .q(reg_out[i]) );
        end
    endgenerate


    always @(*) begin
        send_msg = reg_out[mux_sel];
    end


    SerializerControl #(.N_SAMPLES(N_SAMPLES)) ctrl ( .clk(clk), .reset(reset), .recv_val(recv_val), .recv_rdy(recv_rdy), .send_val(send_val), .send_rdy(send_rdy), .mux_sel(mux_sel), .reg_en(reg_en));     

endmodule


module SerializerControl
    #(
        N_SAMPLES = 8
    )
    (
        input  logic                           recv_val,
        output logic                           recv_rdy,

        output logic                           send_val,
        input  logic                           send_rdy,

        output logic [$clog2(N_SAMPLES) - 1:0] mux_sel,
        output logic                           reg_en,

        input logic                            clk,
        input logic                            reset
    );

    localparam INIT  = 0;
    localparam OUTPUT_START = 1;
    localparam ADD   = 2;

    logic next_state;
    logic state;

    logic [$clog2(N_SAMPLES):0] mux_sel_next;

    always @(*) begin
        case(state)
            INIT:
                begin
                    if(reset == 1) next_state = INIT;
                    if(recv_val == 1) next_state = OUTPUT_START; 
                    else next_state = INIT;
                end
            OUTPUT_START:
                begin
                    if(mux_sel_next!= N_SAMPLES) next_state = OUTPUT_START;
                    else next_state = INIT;
                end
            default:
                next_state = INIT;
        endcase
    end

    always @(*) begin
        case(state)
            INIT:
                begin
                    reg_en       = 1;
                    send_val     = 0;
                    recv_rdy     = 1;
                    mux_sel_next = 0;
                end
            OUTPUT_START:
                begin
                    reg_en   = 0;
                    send_val = 1;
                    recv_rdy = 0;
                    if(send_rdy == 1) mux_sel_next = mux_sel + 1;
                    else              mux_sel_next = mux_sel;
                end
        
        endcase
    end

    always @(posedge clk) begin
        mux_sel <= mux_sel_next;
        state   <= next_state;
    end
endmodule
`line 7 "../../../tape_in_sim/sim/minion_FFT/FFTSPIMinionVRTL.v" 0
`line 1 "../../../C2S2-SERDES/sim/deserializer/DeserializerVRTL.v" 0
module ControlVRTL 
#(
    parameter N_SAMPLES = 8
)(
    input   logic recv_val,
    input   logic send_rdy,


    output  logic send_val,
    output  logic recv_rdy,

    output  logic [N_SAMPLES - 1:0] en_sel,

    input   logic reset,
    input   logic clk
);
    localparam [1:0] INIT =   2'b00;
    localparam [1:0] STATE1 = 2'b01;
    localparam [1:0] STATE2 = 2'b10; 

    logic [$clog2(N_SAMPLES) + 1:0] count; //counter
    logic [$clog2(N_SAMPLES) + 1:0] count_next;

    logic [1:0] next_state;
    logic [1:0] state;

    DecoderVRTL #( .BIT_WIDTH( $clog2(N_SAMPLES) ) ) decoder ( .in(count), .out(en_sel));

    always @(*) begin 
       case(state)
            INIT: begin 

                if (count_next == N_SAMPLES) begin
                    next_state = STATE1;
                end 
                else begin
                    next_state = INIT;
                end

                end

            STATE1: begin
                if(send_rdy == 1) begin
                    next_state = INIT;
                end else begin
                    next_state = STATE1;
                end
            end

            default: next_state = INIT;
        endcase
    end  

    always @(*) begin 

        case(state)
            INIT: begin 
                if(recv_val == 1) begin
                    count_next = count + 1;
                end else begin
                    count_next = count;
                end

                recv_rdy = 1'b1;
                send_val = 1'b0;
            end

            STATE1: begin
            count_next = 0;
            recv_rdy = 1'b0;
            send_val = 1'b1;
            end

            default: begin
                count_next = 0;
                recv_rdy = 1'b1;
                send_val = 1'b0;
            end

        endcase

    end

    always @ (posedge clk) begin 
        if(reset) begin
            count <= 0;
            state <= INIT;
        end else begin
            count <= count_next;
            state <= next_state;
        end
    end 

endmodule

module DecoderVRTL #(
    parameter BIT_WIDTH = 3
)(
	input  logic [BIT_WIDTH - 1:0] in,
	output logic [(1 << BIT_WIDTH) - 1:0] out
);

	always @(*) out = {{1 << BIT_WIDTH - 1 {1'b0}}, 1'b1} << in;
endmodule

`ifndef REGISTER_V
`define REGISTER_V
module RegisterV
	#(parameter BIT_WIDTH  = 32)
	(clk, reset, w, d, q);
    input logic clk;
    input logic reset;
    input  logic w;
    input logic [BIT_WIDTH-1:0] d;
    output logic [BIT_WIDTH-1:0] q;
    logic [BIT_WIDTH-1:0] regout;

    assign q = regout;

    always @(posedge clk) begin
	if (reset)
	    regout <= 0;
	else if (w)
	    regout <= d;
    end
endmodule

`endif

module DeserializerVRTL
#(
    parameter N_SAMPLES = 8,
	parameter BIT_WIDTH  = 32
)(
	
	input  logic recv_val,
    output logic recv_rdy, 	 
	input  logic [BIT_WIDTH - 1:0] recv_msg,

	output logic send_val, 
    input  logic send_rdy,
    output logic [BIT_WIDTH - 1:0] send_msg [N_SAMPLES - 1:0],

    input logic clk, 
	input logic reset
);
    
    logic [N_SAMPLES - 1:0] en_sel;

    //body of code
	ControlVRTL #(.N_SAMPLES(N_SAMPLES)) c
		(
			.recv_val(recv_val), 
			.send_rdy(send_rdy),
			
			.send_val(send_val),
			.recv_rdy(recv_rdy), 

            .reset(reset),
			.clk(clk),

			.en_sel(en_sel)
		);

    generate
        genvar i;
        for( i = 0; i < N_SAMPLES; i++) begin
            RegisterV #( .BIT_WIDTH(BIT_WIDTH) ) register ( .clk(clk), .reset(reset), .w(en_sel[i]), .d(recv_msg), .q(send_msg[i]) );
        end
    endgenerate

endmodule



`line 8 "../../../tape_in_sim/sim/minion_FFT/FFTSPIMinionVRTL.v" 0

module FFTSPIMinionVRTL
#(
    BIT_WIDTH  = 32,
    DECIMAL_PT = 16,
    N_SAMPLES  = 8
)
(
    input  logic             clk,
    input  logic             reset,
    input  logic             cs,
    input  logic             sclk,
    input  logic             mosi,
    output logic             miso,
    input  logic             cs_2,
    input  logic             sclk_2,
    input  logic             mosi_2,
    output logic             miso_2
);

logic                    push_en_1;
logic                    pull_en_1;

logic [BIT_WIDTH + 1:0]  push_msg_1;
logic [BIT_WIDTH - 1:0]  pull_msg_1;
logic                    pull_msg_val_1;
logic                    pull_msg_spc_1;

logic                    push_en_2;
logic                    pull_en_2;

logic [BIT_WIDTH + 1:0]  push_msg_2;
logic [BIT_WIDTH - 1:0]  pull_msg_2;
logic                    pull_msg_val_2;
logic                    pull_msg_spc_2;

logic [BIT_WIDTH - 1:0]  recv_msg_a_1;
logic                    recv_rdy_a_1;
logic                    recv_val_a_1;
logic [BIT_WIDTH - 1:0]  send_msg_a_2;
logic                    send_rdy_a_2;
logic                    send_val_a_2;

logic [BIT_WIDTH - 1:0]  recv_msg_s   [N_SAMPLES - 1:0];
logic                    recv_rdy_s;
logic                    recv_val_s;
logic [BIT_WIDTH - 1:0]  send_msg_s;
logic                    send_rdy_s;
logic                    send_val_s;

logic [BIT_WIDTH - 1:0]  recv_msg_d;
logic                    recv_rdy_d;
logic                    recv_val_d;
logic [BIT_WIDTH - 1:0]  send_msg_d   [N_SAMPLES - 1:0];
logic                    send_rdy_d;
logic                    send_val_d;

logic                    minion1_parity;
logic                    minion2_parity;
logic                    adapter1_parity;
logic                    adapter2_parity;

SPI_minion_components_SPIMinionVRTL #(.nbits(BIT_WIDTH+2)) minion1
(
    .clk(clk),
    .cs(cs),
    .miso(miso),
    .mosi(mosi),
    .reset(reset),
    .sclk(sclk),
    .pull_en(pull_en_1),
    .pull_msg({pull_msg_val_1, pull_msg_spc_1, pull_msg_1}),
    .push_en(push_en_1),
    .push_msg(push_msg_1),  
    .parity(minion1_parity)
);

SPI_minion_components_SPIMinionAdapterVRTL #(.nbits(BIT_WIDTH+2), .num_entries(N_SAMPLES)) adapter1
(
    .clk(clk),
    .reset(reset),
    .pull_en(pull_en_1),
    .pull_msg_val(pull_msg_val_1),
    .pull_msg_spc(pull_msg_spc_1),
    .pull_msg_data(pull_msg_1),
    .push_en(push_en_1),
    .push_msg_val_wrt(push_msg_1[BIT_WIDTH + 1]),
    .push_msg_val_rd(push_msg_1[BIT_WIDTH]),
    .push_msg_data(push_msg_1[BIT_WIDTH - 1:0]),  
    .recv_msg(recv_msg_a_1),
    .recv_val(recv_val_a_1),
    .recv_rdy(recv_rdy_a_1),

    .send_msg(recv_msg_d),
    .send_val(recv_val_d),
    .send_rdy(recv_rdy_d),
    .parity(adapter1_parity)
);

DeserializerVRTL #(.BIT_WIDTH(BIT_WIDTH), .N_SAMPLES(N_SAMPLES)) deserializer(
    .clk(clk),
    .reset(reset),
    .recv_msg(recv_msg_d),
    .recv_val(recv_val_d),
    .recv_rdy(recv_rdy_d),

    .send_msg(send_msg_d),
    .send_val(send_val_d),
    .send_rdy(send_rdy_d)
);

FFTVRTL #(.BIT_WIDTH(BIT_WIDTH), .DECIMAL_PT(DECIMAL_PT), .N_SAMPLES(N_SAMPLES)) FFT(
    .clk(clk),
    .reset(reset),
    .recv_msg(send_msg_d),
    .recv_val(send_val_d),
    .recv_rdy(send_rdy_d),

    .send_msg(recv_msg_s),
    .send_val(recv_val_s),
    .send_rdy(recv_rdy_s)
);

SerializerVRTL #(.BIT_WIDTH(BIT_WIDTH), .N_SAMPLES(N_SAMPLES)) serializer(
    .clk(clk),
    .reset(reset),
    .recv_msg(recv_msg_s),
    .recv_val(recv_val_s),
    .recv_rdy(recv_rdy_s),

    .send_msg(send_msg_s),
    .send_val(send_val_s),
    .send_rdy(send_rdy_s)
);

SPI_minion_components_SPIMinionAdapterVRTL #(.nbits(BIT_WIDTH+2), .num_entries(N_SAMPLES)) adapter2
(
    .clk(clk),
    .reset(reset),
    .pull_en(pull_en_2),
    .pull_msg_val(pull_msg_val_2),  // add these 3
    .pull_msg_spc(pull_msg_spc_2),  // add these 3
    .pull_msg_data(pull_msg_2),     // add these 3
    .push_en(push_en_2),
    .push_msg_val_wrt(push_msg_2[BIT_WIDTH + 1]), // don't care
    .push_msg_val_rd(push_msg_2[BIT_WIDTH]), // don't care
    .push_msg_data(push_msg_2[BIT_WIDTH - 1:0]), // don't care
    .recv_msg(send_msg_s),
    .recv_val(send_val_s),
    .recv_rdy(send_rdy_s),

    .send_msg(send_msg_a_2),
    .send_val(send_val_a_2),
    .send_rdy(send_rdy_a_2),
    .parity(adapter2_parity)
);

SPI_minion_components_SPIMinionVRTL #(.nbits(BIT_WIDTH+2)) minion2
(
    .clk(clk),
    .cs(cs_2),
    .miso(miso_2),
    .mosi(mosi_2),
    .reset(reset),
    .sclk(sclk_2),
    .pull_en(pull_en_2),
    .pull_msg({pull_msg_val_2, pull_msg_spc_2, pull_msg_2}), // val+space+[15:0]
    .push_en(push_en_2),
    .push_msg(push_msg_2),  
    .parity(minion2_parity)
);

assign recv_val_a_1 = 0;
assign recv_msg_a_1 = 0;
assign send_rdy_a_2 = 0;

endmodule

`endif
`line 7 "tape_in_FFT_interconnectVRTL.v" 0
`line 1 "../../../C2S2-PacketRoutingInterconnect/sim/BlockingXBar/crossbarVRTL.v" 0
`ifndef PROJECT_CROSSBAR_V
`define PROJECT_CROSSBAR_V


//Crossbar in Verilog

module crossbarVRTL
    #(
        parameter BIT_WIDTH = 32, 
        parameter N_INPUTS = 2,
        parameter N_OUTPUTS = 2,
        parameter CONTROL_BIT_WIDTH = 42
    )
    (
        input  logic [BIT_WIDTH - 1:0] recv_msg [0:N_INPUTS - 1] ,
        input  logic                   recv_val [0:N_INPUTS - 1] ,
        output logic                   recv_rdy [0:N_INPUTS - 1] ,

        output logic [BIT_WIDTH - 1:0] send_msg [0:N_OUTPUTS - 1],
        output logic                   send_val [0:N_OUTPUTS - 1],
        input  logic                   send_rdy [0:N_OUTPUTS - 1],

        input  logic                   reset                     ,
        input  logic                   clk                       ,

        input  logic [CONTROL_BIT_WIDTH - 1:0]      control      ,
        input  logic                   control_val               ,
        output logic                   control_rdy               
    );

    logic [CONTROL_BIT_WIDTH - 1:0] stored_control;

    always @(posedge clk) begin

        for (integer i = 0; i < N_OUTPUTS; i = i+1) begin
            send_msg[i] = 0;
            send_val[i] = 0;
        end
        for (integer j = 0; j < N_INPUTS; j = j+1) begin
            recv_rdy[j] = 0;
        end
        if ( reset ) begin
            stored_control = 0;
        end
        else if ( control_val ) begin
            stored_control = control;
        end
    end

    assign control_rdy = 1;

    logic [$clog2(N_INPUTS)  - 1:0] input_sel;
    logic [N_OUTPUTS - 1:0] output_sel;

    assign input_sel = stored_control[CONTROL_BIT_WIDTH - 1: CONTROL_BIT_WIDTH-$clog2(N_INPUTS)];

    assign output_sel = stored_control[CONTROL_BIT_WIDTH - $clog2(N_INPUTS) : CONTROL_BIT_WIDTH-$clog2(N_INPUTS)-$clog2(N_OUTPUTS)];

    always @(*) begin
        for (integer i = 0; i < N_OUTPUTS; i = i+1) begin
            if ( (i == output_sel)) begin
                send_msg[i] = recv_msg[input_sel];
                send_val[i] = recv_val[input_sel];
            end
            else begin
                send_msg[i] = 0;
                send_val[i] = 0;
            end
        end

        for (integer j = 0; j < N_INPUTS; j = j+1) begin
            if (j == input_sel) begin
                recv_rdy[j] = send_rdy[output_sel]; 
            end
            else begin
                recv_rdy[j] = 0;
            end
        end
    end
    
endmodule

`endif
`line 8 "tape_in_FFT_interconnectVRTL.v" 0
`line 1 "../../../C2S2-PacketRoutingInterconnect/sim/Router/routerVRTL.v" 0
`line 1 "../../../C2S2-PacketRoutingInterconnect/sim/Router/muxes.v" 0
//========================================================================
// Verilog Components: Muxes
//========================================================================

`ifndef VC_MUXES_V
`define VC_MUXES_V

//------------------------------------------------------------------------
// 2 Input Mux
//------------------------------------------------------------------------

module vc_Mux2
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1,
  input  logic               sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      1'd0 : out = in0;
      1'd1 : out = in1;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 3 Input Mux
//------------------------------------------------------------------------

module vc_Mux3
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 4 Input Mux
//------------------------------------------------------------------------

module vc_Mux4
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      2'd3 : out = in3;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 5 Input Mux
//------------------------------------------------------------------------

module vc_Mux5
#(
 parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 6 Input Mux
//------------------------------------------------------------------------

module vc_Mux6
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 7 Input Mux
//------------------------------------------------------------------------

module vc_Mux7
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 8 Input Mux
//------------------------------------------------------------------------

module vc_Mux8
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6, in7,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      3'd7 : out = in7;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// N Input Mux
//------------------------------------------------------------------------

module vc_MuxN
#(
  parameter p_nbits = 1,
  parameter p_ninputs = 2
)(
  input  logic [p_ninputs-1:0][p_nbits-1:0] in,
  input  logic [$clog2(p_ninputs)-1:0]      sel,
  output logic [p_nbits-1:0]                out
);

  assign out = in[sel];

endmodule

`endif /* VC_MUXES_V */

`line 2 "../../../C2S2-PacketRoutingInterconnect/sim/Router/routerVRTL.v" 0
`line 1 "../../../C2S2-PacketRoutingInterconnect/sim/Router/parametricDemuxVRTL.v" 0
module parametricDemuxVRTL
#(
  //length of message
  parameter p_nbits = 1,   
  //Number of outputs
  parameter p_noutputs = 2
)
(
  input  logic [p_nbits-1:0]                  in_val,
  input  logic [$clog2(p_noutputs)-1:0]       sel,
  output logic [p_nbits-1:0] out_val [p_noutputs-1:0]
);
  genvar i;
  generate
    for (i = 0; i < p_noutputs; i = i + 1) begin : output_gen
      assign out_val[i] = (i == sel) ? in_val : {p_nbits{1'b0}};
    end
  endgenerate
endmodule


`line 3 "../../../C2S2-PacketRoutingInterconnect/sim/Router/routerVRTL.v" 0

module routerVRTL
#(
  parameter p_nbits = 32,
  parameter p_noutputs = 8
)(
  input logic                                                    valid,
 
  input logic  [p_nbits-1:0]                                     message_in, 
  output logic                                                  ready_out,
  
  output logic                                  valid_out[0:p_noutputs-1], 
  input logic ready [p_noutputs-1:0], 
  output logic [p_nbits-$clog2(p_noutputs)-1:0] message_out [0:p_noutputs-1]
);

logic valid_holder [p_noutputs-1:0];
logic [p_nbits-1 : p_nbits-$clog2(p_noutputs)] select;
logic [p_nbits-$clog2(p_noutputs)-1:0] cut_message;
logic [p_noutputs-1:0] temp_ready;

assign select = message_in[p_nbits-1 : p_nbits-$clog2(p_noutputs)];
assign cut_message = message_in[p_nbits-$clog2(p_noutputs)-1:0];

  //Ready bit
  vc_MuxN #(                   
    .p_nbits(1),               
    .p_ninputs(p_noutputs)     
  ) mux_inst (
    .in(temp_ready),
    .sel(select),
    .out(ready_out)
  );

  //Valid bit
  parametricDemuxVRTL #(       
    .p_nbits(1),               
    .p_noutputs(p_noutputs)     
  ) demux_inst (
    .in_val(valid),
    .sel(select),
    .out_val(valid_holder)
  );

  //Used to set valid bits to zero in the case the block is not ready
  generate
    for ( genvar i = 0; i < p_noutputs; i = i + 1) begin 
      assign valid_out[i] = (ready_out == 1) ? valid_holder[i] : 1'b0;
    end
  endgenerate

  //Assigns all the output wires to cut_message
  generate
    for ( genvar j = 0; j < p_noutputs; j = j + 1) begin 
      assign message_out[j] = cut_message;
    end
  endgenerate

  //Ready is not of correct form for the mux. Needs to be changed...
  //Mismatch between port which is not an array, and expression which is an array.
  generate
    for ( genvar k = 0; k < p_noutputs; k = k + 1) begin 
      assign temp_ready[k +: 1] = ready[p_noutputs-k-1]; 
    end
  endgenerate
endmodule

`line 9 "tape_in_FFT_interconnectVRTL.v" 0
`line 1 "../../../C2S2-PacketRoutingInterconnect/sim/Arbiter/ArbitratorVRTL.v" 0
// ==========================================================================
// Arbitrator.py
// ==========================================================================
// This module is used to pick which component gets to output to the val/rdy SPI wrapper if multiple components can send a valid message.
// The arbitrator puts an address header on the outgoing packet so that downstream components can tell which component sent the response
// The nbits parameter is the length of the message.
// The num_inputs parameter is the number of input components that the Arbitrator is selecting from. MUST be >= 2

// Author : Dilan Lakhani
//   Date : Dec 19, 2021


module ArbitratorVRTL
#(
  parameter nbits = 32,
  parameter num_inputs = 3,
  parameter addr_nbits = $clog2(num_inputs)
)
(
  input logic clk,
  input logic reset,

  // Receive Interface - need req signals for each component connected to arbitrator
  // input                          req_val [0:num_inputs-1],
  // output                         req_rdy [0:num_inputs-1],
  // input  [nbits-1:0]             req_msg [0:num_inputs-1],

  // Send Interface
  //output                         resp_val,
  //input                          resp_rdy,
  //output [addr_nbits+nbits-1:0]  resp_msg

    // Receive Interface - need recv signals for each component connected to arbitrator
  input   logic                       recv_val [0:num_inputs-1],
  output  logic                       recv_rdy [0:num_inputs-1],
  input   logic [nbits-1:0]           recv_msg [0:num_inputs-1],

  // Send Interface
  output logic                        send_val,
  input  logic                        send_rdy,
  output logic [addr_nbits+nbits-1:0] send_msg
);

  // logic [addr_nbits-1:0] grants_index; // which input is granted access to send to SPI
  // logic [addr_nbits-1:0] old_grants_index;
  // logic [addr_nbits-1:0] encoder_out;

  // assign resp_val = req_val[grants_index] & req_rdy[grants_index];
  // assign resp_msg = {grants_index, req_msg[grants_index]}; // append component address to the beginning of the message
  

  logic [addr_nbits-1:0] grants_index; // which input is granted access to send to SPI
  logic [addr_nbits-1:0] old_grants_index;
  logic [addr_nbits-1:0] encoder_out;
  logic [nbits-1:0]      send_msg_data;
  logic [addr_nbits-1:0] send_msg_addr;

  assign send_msg_data = recv_msg[grants_index];
  assign send_msg_addr = grants_index;
  assign send_val = recv_val[grants_index] & recv_rdy[grants_index];
  assign send_msg = {send_msg_addr, send_msg_data}; // append component address to the beginning of the message  
  
  
  always_comb begin
    // change grants_index if the last cycle's grant index is 0 (that component has finished sending its message)
    if (!recv_val[old_grants_index]) begin
      grants_index = encoder_out;
    end
    else begin
      grants_index = grants_index;
    end
  end

  always_comb begin
    for (integer j=0; j<num_inputs;j++) begin
      // Only tell one input that the arbitrator is ready for it
      if(grants_index == j) begin
        recv_rdy[j] = send_rdy;
      end else begin
        recv_rdy[j] = 1'b0;
      end
    end
  end
    
  always_comb begin
    // priority encoder that gives highest priority to the LSB and lowest to MSB
    encoder_out = 0;
    for(integer i=0; i<num_inputs; i++) begin
      if (recv_val[num_inputs-1-i]) begin
        encoder_out = num_inputs-1-i;
      end
    end
  end

  // One issue arises with having multiple Disassemblers. Since the SPI width is normally less than the size of a response,
  // a PacketDisassembler component needs multiple cycles to fully send a message to the arbitrator. Thus, we do not want to 
  // change which Disassembler is allowed to send to the Arbitrator in the middle of a message.
  // Fix this by holding a trailing value of the grants_index.
  // We need to be able to check the req_val of the old grants_index to make sure that it is not 1, then we can allow a different
  // Disassembler to send a message
  always_ff @(posedge clk) begin
    if (reset) begin
      old_grants_index <= 0;
    end
    else begin
      old_grants_index <= grants_index;
    end
  end

endmodule



`line 10 "tape_in_FFT_interconnectVRTL.v" 0

module tape_in_FFT_interconnectVRTL
#(
    BIT_WIDTH  = 32,
    DECIMAL_PT = 16,
    N_SAMPLES  = 256
)
(
    input  logic             clk,
    input  logic             reset,

    input  logic             minion_cs,
    input  logic             minion_sclk,
    input  logic             minion_mosi,
    output logic             minion_miso,
    output logic             minion_parity ,
    output logic             adapter_parity,

    input  logic             minion_cs_2,
    input  logic             minion_sclk_2,
    input  logic             minion_mosi_2,
    output logic             minion_miso_2,

    

    input  logic             minion_cs_3,
    input  logic             minion_sclk_3,
    input  logic             minion_mosi_3,
    output logic             minion_miso_3,


    output logic             master_cs  ,
    input  logic             master_miso,
    output logic             master_mosi,
    output logic             master_sclk

);

localparam MAX_ADDRESSABLE_SRCS_POW_2 = 16;
localparam MAX_ADDRESSABLE_SRC_LOG2 = $clog2(MAX_ADDRESSABLE_SRCS_POW_2);

logic                   spi_minion_send_val;
logic                   spi_minion_send_rdy;
logic [BIT_WIDTH + MAX_ADDRESSABLE_SRC_LOG2 - 1:0] spi_minion_send_msg;

logic                   spi_minion_recv_val;
logic                   spi_minion_recv_rdy;
logic [BIT_WIDTH + MAX_ADDRESSABLE_SRC_LOG2 - 1:0] spi_minion_recv_msg;

logic                   module_interconnect_src_val[0:MAX_ADDRESSABLE_SRCS_POW_2 - 1];
logic                   module_interconnect_src_rdy[0:MAX_ADDRESSABLE_SRCS_POW_2 - 1];
logic [BIT_WIDTH - 1:0] module_interconnect_src_msg[0:MAX_ADDRESSABLE_SRCS_POW_2 - 1];

logic                   module_interconnect_snk_val[0:MAX_ADDRESSABLE_SRCS_POW_2 - 1];
logic                   module_interconnect_snk_rdy[0:MAX_ADDRESSABLE_SRCS_POW_2 - 1];
logic [BIT_WIDTH - 1:0] module_interconnect_snk_msg[0:MAX_ADDRESSABLE_SRCS_POW_2 - 1];

logic                   spi_master_send_val;
logic                   spi_master_send_rdy;
logic [BIT_WIDTH - 1:0] spi_master_send_msg;

logic                   spi_master_recv_val;
logic                   spi_master_recv_rdy[0:0];
logic [BIT_WIDTH - 1:0] spi_master_recv_msg;

logic [BIT_WIDTH - 1:0] fft_input_xbar_recv_msg[0:1];
logic fft_input_xbar_recv_val[0:1];
logic fft_input_xbar_recv_rdy[0:1];

logic [BIT_WIDTH - 1:0] fft_input_xbar_send_msg[0:1];
logic fft_input_xbar_send_val[0:1];
logic fft_input_xbar_send_rdy[0:1];

logic intermediate_msg[0:0];

logic [BIT_WIDTH - 1:0] fft_output_xbar_recv_msg[0:1];
logic fft_output_xbar_recv_val[0:1];
logic fft_output_xbar_recv_rdy[0:1];

logic [BIT_WIDTH - 1:0] spi_master_xbar_recv_msg[0:1];
logic spi_master_xbar_recv_val[0:1];
logic spi_master_xbar_recv_rdy[0:1];

logic [BIT_WIDTH - 1:0]  recv_msg_s   [N_SAMPLES - 1:0];
logic                    recv_rdy_s;
logic                    recv_val_s;



logic [BIT_WIDTH - 1:0]  send_msg_d   [N_SAMPLES - 1:0];
logic                    send_rdy_d;
logic                    send_val_d;

SPIMinionAdapterConnectedVRTL #(.BIT_WIDTH(BIT_WIDTH + MAX_ADDRESSABLE_SRC_LOG2), .N_SAMPLES(N_SAMPLES) ) ctrl_spi_minion 
                (.clk(clk), .reset(reset), .cs(minion_cs), .sclk(minion_sclk), .mosi(minion_mosi), .miso(minion_miso),
                 .recv_msg(spi_minion_recv_msg), .recv_rdy(spi_minion_recv_rdy), .recv_val(spi_minion_recv_val), 
                 .send_msg(spi_minion_send_msg), .send_rdy(spi_minion_send_rdy), .send_val(spi_minion_send_val),
                 .minion_parity(minion_parity), .adapter_parity(adapter_parity));

ArbitratorVRTL #(.nbits(BIT_WIDTH), 
             .num_inputs(MAX_ADDRESSABLE_SRCS_POW_2)) arbiter 
             ( 
             .clk(clk), 
             .reset(reset), 

             .recv_val(module_interconnect_snk_val), 
             .recv_rdy(module_interconnect_snk_rdy), 
             .recv_msg(module_interconnect_snk_msg), 

             .send_val(spi_minion_recv_msg), 
             .send_rdy(spi_minion_recv_rdy), 
             .send_msg(spi_minion_recv_val));

routerVRTL #(.p_nbits(BIT_WIDTH + MAX_ADDRESSABLE_SRC_LOG2), .p_noutputs(MAX_ADDRESSABLE_SRCS_POW_2)) router
            (
                .valid     (spi_minion_send_val),
                .ready_out (spi_minion_send_rdy),
                .message_in(spi_minion_send_msg),
                
                .valid_out  (module_interconnect_src_val),
                .ready      (module_interconnect_src_rdy),
                .message_out(module_interconnect_src_msg)
            );

//Address 0: Loopack through the arbiters back to the SPI adapter. 
assign module_interconnect_snk_val[0] = module_interconnect_src_val[0];
assign module_interconnect_src_rdy[0] = module_interconnect_snk_rdy[0];
assign module_interconnect_snk_msg[0] = module_interconnect_src_msg[0];



//Address 1: FFT Input Crossbar Control
crossbarVRTL #(.BIT_WIDTH(BIT_WIDTH), .N_INPUTS(2), .N_OUTPUTS(2), .CONTROL_BIT_WIDTH(BIT_WIDTH + MAX_ADDRESSABLE_SRC_LOG2)) fft_input_xbar  (.clk(clk), 
                                                                                    .reset(reset), 
                                                                                    
                                                                                    .recv_msg(fft_input_xbar_recv_msg), 
                                                                                    .recv_val(fft_input_xbar_recv_val), 
                                                                                    .recv_rdy(fft_input_xbar_recv_rdy), 
                                                                                    
                                                                                    .send_msg(fft_input_xbar_send_msg), 
                                                                                    .send_val(fft_input_xbar_send_val), 
                                                                                    .send_rdy(fft_input_xbar_send_rdy), 
                                                                                    
                                                                                    .control    (module_interconnect_src_msg[1]), 
                                                                                    .control_val(module_interconnect_src_val[1]), 
                                                                                    .control_rdy(module_interconnect_src_rdy[1]));



assign fft_input_xbar_recv_msg[0]     = module_interconnect_src_msg[7];
assign fft_input_xbar_recv_val[0]     = module_interconnect_src_val[7];
assign module_interconnect_src_rdy[7] = fft_input_xbar_recv_rdy[0];

assign fft_input_xbar_recv_msg[1] = spi_master_send_msg;
assign fft_input_xbar_recv_val[1] = spi_master_send_val;
assign spi_master_send_val        = fft_input_xbar_recv_rdy[1];





assign module_interconnect_snk_rdy[1] = intermediate_msg[0];

//Address 2: FFT Output Crossbar Control
crossbarVRTL #(.BIT_WIDTH(BIT_WIDTH), .N_INPUTS(2), .N_OUTPUTS(1), .CONTROL_BIT_WIDTH(BIT_WIDTH + MAX_ADDRESSABLE_SRC_LOG2)) fft_output_xbar (.clk(clk), 
                                                                                    .reset(reset), 
                                                                                    
                                                                                    .recv_msg(fft_output_xbar_recv_msg), 
                                                                                    .recv_val(fft_output_xbar_recv_val), 
                                                                                    .recv_rdy(fft_output_xbar_recv_rdy), 
                                                                                    
                                                                                    .send_msg(module_interconnect_snk_msg[1]), 
                                                                                    .send_val(module_interconnect_snk_val[1]), 
                                                                                    .send_rdy(module_interconnect_snk_rdy[1:1]), 
                                                                                    
                                                                                    .control    (module_interconnect_src_msg[2]), 
                                                                                    .control_val(module_interconnect_src_val[2]), 
                                                                                    .control_rdy(module_interconnect_src_rdy[2]));



//Address 6: SPI Master Crossbar 
crossbarVRTL #(.BIT_WIDTH(BIT_WIDTH), .N_INPUTS(2), .N_OUTPUTS(1), .CONTROL_BIT_WIDTH(BIT_WIDTH + MAX_ADDRESSABLE_SRC_LOG2)) spi_master_xbar (.clk(clk), 
                                                                                    .reset(reset), 
                                                                                    
                                                                                    .recv_msg(spi_master_xbar_recv_msg), 
                                                                                    .recv_val(spi_master_xbar_recv_val), 
                                                                                    .recv_rdy(spi_master_xbar_recv_rdy), 
                                                                                    
                                                                                    .send_msg(spi_master_recv_msg), 
                                                                                    .send_val(spi_master_recv_val), 
                                                                                    .send_rdy(spi_master_recv_rdy[0:0]), 
                                                                                    
                                                                                    .control    (module_interconnect_src_msg[6]), 
                                                                                    .control_val(module_interconnect_src_val[6]), 
                                                                                    .control_rdy(module_interconnect_src_rdy[6]));



assign spi_master_xbar_recv_msg[0]     = module_interconnect_src_msg[8];
assign spi_master_xbar_recv_val[0]     = module_interconnect_src_val[8];
assign module_interconnect_src_rdy[8]  = spi_master_xbar_recv_rdy[0];

assign spi_master_xbar_recv_msg[1] = 0;
assign spi_master_xbar_recv_val[1] = 1;



SPIMasterValRdyVRTL #(.nbits(32), .ncs(1)) spi_master (
  .clk(clk), 
  .reset(reset), 
  
  .spi_ifc_cs  (master_cs  ), 
  .spi_ifc_miso(master_miso),
  .spi_ifc_mosi(master_mosi),
  .spi_ifc_sclk(master_sclk),

  .recv_val(spi_master_send_val),
  .recv_rdy(spi_master_send_rdy),
  .recv_msg(spi_master_send_msg),

  .send_val(spi_master_recv_val),
  .send_rdy(spi_master_recv_rdy),
  .send_msg(spi_master_recv_msg),

  .packet_size_ifc_val(module_interconnect_src_msg[5]), //Address 5: SPI Master Packet Size Select
  .packet_size_ifc_rdy(module_interconnect_src_val[5]),
  .packet_size_ifc_msg(module_interconnect_src_rdy[5]),

  .cs_addr_ifc_val(module_interconnect_src_msg[4]), // Address 4: SPI Master Chip Select
  .cs_addr_ifc_rdy(module_interconnect_src_val[4]),
  .cs_addr_ifc_msg(module_interconnect_src_rdy[4]),

  .freq_ifc_val(module_interconnect_src_msg[3]), //new //Address 3: SPI Master Frequency Select
  .freq_ifc_rdy(module_interconnect_src_val[3]), //new 
  .freq_ifc_msg(module_interconnect_src_rdy[3]) //new
  );




DeserializerVRTL #(.BIT_WIDTH(BIT_WIDTH), .N_SAMPLES(N_SAMPLES)) deserializer(
    .clk(clk),
    .reset(reset),
    .recv_msg(fft_input_xbar_send_msg[0]),
    .recv_val(fft_input_xbar_send_val[0]),
    .recv_rdy(fft_input_xbar_send_rdy[0]),

    .send_msg(send_msg_d),
    .send_val(send_val_d),
    .send_rdy(send_rdy_d)
);

FFTVRTL #(.BIT_WIDTH(BIT_WIDTH), .DECIMAL_PT(DECIMAL_PT), .N_SAMPLES(N_SAMPLES)) FFT(
    .clk(clk),
    .reset(reset),
    .recv_msg(send_msg_d),
    .recv_val(send_val_d),
    .recv_rdy(send_rdy_d),

    .send_msg(recv_msg_s),
    .send_val(recv_val_s),
    .send_rdy(recv_rdy_s)
);

SerializerVRTL #(.BIT_WIDTH(BIT_WIDTH), .N_SAMPLES(N_SAMPLES)) serializer(
    .clk(clk),
    .reset(reset),
    .recv_msg(recv_msg_s),
    .recv_val(recv_val_s),
    .recv_rdy(recv_rdy_s),

    .send_msg(fft_output_xbar_recv_msg[1]),
    .send_val(fft_output_xbar_recv_val[1]),
    .send_rdy(fft_output_xbar_recv_rdy[1])
);



FFTSPIMinionVRTL #(.BIT_WIDTH(BIT_WIDTH), .DECIMAL_PT(DECIMAL_PT), .N_SAMPLES(8)) tape_in_one_model (
                   .clk(clk), .reset(reset), 
                   .cs(minion_cs_2), .sclk(minion_sclk_2), .mosi(minion_mosi_2), .miso(minion_miso_2), 
                   .cs_2(minion_cs_3), .sclk_2(minion_sclk_3), .mosi_2(minion_mosi_3), .miso_2(minion_miso_3));



endmodule

`endif
`endif /* TAPE_IN_FFT_INTERCONNECTVRTL */
//-----------------------------------------------------------
// Wrapper of placeholder tape_in_FFT_interconnectVRTL_noparam
//-----------------------------------------------------------

`ifndef TAPE_IN_FFT_INTERCONNECTVRTL_NOPARAM
`define TAPE_IN_FFT_INTERCONNECTVRTL_NOPARAM

module FFTSPIMinionRTL
(
  output logic [1-1:0] adapter_parity ,
  input logic [1-1:0] clk ,
  output logic [1-1:0] minion_parity ,
  input logic [1-1:0] reset ,
  input logic [1-1:0] minion_cs ,
  input logic [1-1:0] minion_cs_2 ,
  input logic [1-1:0] minion_cs_3 ,
  output logic [1-1:0] minion_miso ,
  output logic [1-1:0] minion_miso_2 ,
  output logic [1-1:0] minion_miso_3 ,
  input logic [1-1:0] minion_mosi ,
  input logic [1-1:0] minion_mosi_2 ,
  input logic [1-1:0] minion_mosi_3 ,
  output logic [1-1:0] master_cs ,
  input logic [1-1:0] master_miso ,
  output logic [1-1:0] master_mosi ,
  output logic [1-1:0] master_sclk ,
  input logic [1-1:0] minion_sclk ,
  input logic [1-1:0] minion_sclk_2 ,
  input logic [1-1:0] minion_sclk_3 
);
  tape_in_FFT_interconnectVRTL
  #(
  ) v
  (
    .adapter_parity( adapter_parity ),
    .clk( clk ),
    .minion_parity( minion_parity ),
    .reset( reset ),
    .minion_cs( minion_cs ),
    .minion_cs_2( minion_cs_2 ),
    .minion_cs_3( minion_cs_3 ),
    .minion_miso( minion_miso ),
    .minion_miso_2( minion_miso_2 ),
    .minion_miso_3( minion_miso_3 ),
    .minion_mosi( minion_mosi ),
    .minion_mosi_2( minion_mosi_2 ),
    .minion_mosi_3( minion_mosi_3 ),
    .master_cs( master_cs ),
    .master_miso( master_miso ),
    .master_mosi( master_mosi ),
    .master_sclk( master_sclk ),
    .minion_sclk( minion_sclk ),
    .minion_sclk_2( minion_sclk_2 ),
    .minion_sclk_3( minion_sclk_3 )
  );
endmodule

`endif /* TAPE_IN_FFT_INTERCONNECTVRTL_NOPARAM */

